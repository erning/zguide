<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Point-to-Point Messaging</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="ch08.html" title="Chapter 8. A Framework for Distributed Computing" /><link rel="prev" href="ch08s04.html" title="Spinning Off a Library Project" /><link rel="next" href="ch08s06.html" title="Group Messaging" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Point-to-Point Messaging</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch08s04.html">Prev</a> </td><th width="60%" align="center">Chapter 8. A Framework for Distributed Computing</th><td width="20%" align="right"> <a accesskey="n" href="ch08s06.html">Next</a></td></tr></table><hr /></div><div class="sect1" title="Point-to-Point Messaging"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp21316632"></a>Point-to-Point Messaging</h2></div></div></div><p>I'm going to take the last UDP ping program and build a point-to-point messaging layer on top of that. Our goal is that we can detect peers as they join and leave the network, that we can send messages to them, and that we can get replies. It is a nontrivial problem to solve and takes Min and me two days to get a "Hello World" version working.</p><p>We had to solve a number of issues:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>What information to send in the UDP beacon, and how to format it.</p></li><li class="listitem"><p>What ØMQ socket types to use to interconnect nodes.</p></li><li class="listitem"><p>What ØMQ messages to send, and how to format them.</p></li><li class="listitem"><p>How to send a message to a specific node.</p></li><li class="listitem"><p>How to know the sender of any message so we could send a reply.</p></li><li class="listitem"><p>How to recover from lost UDP beacons.</p></li><li class="listitem"><p>How to avoid overloading the network with beacons.</p></li></ul></div><p>I'll explain these in enough detail so that you understand why we made each choice we did, with some code fragments to illustrate. We tagged this code as <a class="ulink" href="https://github.com/zeromq/zyre/zipball/v0.1.0" target="_top">version 0.1.0</a> so you can look at the code: most of the hard work is done in <code class="literal">zre_interface.c</code>.</p><div class="sect2" title="UDP Beacon Framing"><div class="titlepage"><div><div><h3 class="title"><a id="idp21321312"></a>UDP Beacon Framing</h3></div></div></div><p>Sending UUIDs across the network is the bare minimum for a logical addressing scheme. However, we have a few more aspects to get working before this will work in real use:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>We need some protocol identification so that we can check for and reject invalid packets.</p></li><li class="listitem"><p>We need some version information so that we can change this protocol over time.</p></li><li class="listitem"><p>We need to tell other nodes how to reach us via TCP, i.e., a ØMQ port they can talk to us on.</p></li></ul></div><p>Let's start with the beacon message format. We probably want a fixed protocol header that will never change in future versions and a body that depends on the version<a class="xref" href="ch08s05.html#figure-67" title="Figure 8.1. ZRE discovery message">Figure 8.1, “ZRE discovery message”</a>.</p><div class="figure"><a id="figure-67"></a><p class="title"><strong>Figure 8.1. ZRE discovery message</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/fig67.png" alt="ZRE discovery message" /></div></div></div><br class="figure-break" /><p>The version can be a 1-byte counter starting at 1. The UUID is 16 bytes and the port is a 2-byte port number because UDP nicely tells us the sender's IP address for every message we receive. This gives us a 22-byte frame.</p><p>The C language (and a few others like Erlang) make it simple to read and write binary structures. We define the beacon frame structure:</p><pre class="programlisting">
#define BEACON_PROTOCOL     "ZRE"
#define BEACON_VERSION      0x01

typedef struct {
    byte protocol [3];
    byte version;
    uuid_t uuid;
    uint16_t port;
} beacon_t;
</pre><p>This makes sending and receiving beacons quite simple. Here is how we send a beacon, using the <code class="literal">zre_udp</code> class to do the nonportable network calls:</p><pre class="programlisting">
//  Beacon object
beacon_t beacon;

//  Format beacon fields
beacon.protocol [0] = 'Z';
beacon.protocol [1] = 'R';
beacon.protocol [2] = 'E';
beacon.version = BEACON_VERSION;
memcpy (beacon.uuid, self-&gt;uuid, sizeof (uuid_t));
beacon.port = htons (self-&gt;port);

//  Broadcast the beacon to anyone who is listening
zre_udp_send (self-&gt;udp, (byte *) &amp;beacon, sizeof (beacon_t));
</pre><p>When we receive a beacon, we need to guard against bogus data. We're not going to be paranoid against, for example, denial-of-service attacks. We just want to make sure that we're not going to crash when a bad ZRE implementation sends us erroneous frames.</p><p>To validate a frame, we check its size and header. If those are OK, we assume the body is usable. When we get a UUID that isn't ourselves (recall, we'll get our own UDP broadcasts back), we can treat this as a peer:</p><pre class="programlisting">
//  Get beacon frame from network
beacon_t beacon;
ssize_t size = zre_udp_recv (self-&gt;udp,
    (byte *) &amp;beacon, sizeof (beacon_t));

//  Basic validation on the frame
if (size != sizeof (beacon_t)
||  beacon.protocol [0] != 'Z'
||  beacon.protocol [1] != 'R'
||  beacon.protocol [2] != 'E'
||  beacon.version != BEACON_VERSION)
    return 0;               //  Ignore invalid beacons

//  If we got a UUID and it's not our own beacon, we have a peer
if (memcmp (beacon.uuid, self-&gt;uuid, sizeof (uuid_t))) {
    char *identity = s_uuid_str (beacon.uuid);
    s_require_peer (self, identity,
        zre_udp_from (self-&gt;udp), ntohs (beacon.port));
    free (identity);
}
</pre></div><div class="sect2" title="True Peer Connectivity (Harmony Pattern)"><div class="titlepage"><div><div><h3 class="title"><a id="idp21330872"></a>True Peer Connectivity (Harmony Pattern)</h3></div></div></div><p>Because ØMQ is designed to make distributed messaging easy, people often ask how to interconnect a set of true peers (as compared to obvious clients and servers). It is a thorny question and ØMQ doesn't really provide a single clear answer.</p><p>TCP, which is the most commonly-used transport in ØMQ, is not symmetric; one side must bind and one must connect and though ØMQ tries to be neutral about this, it's not. When you connect, you create an outgoing message pipe. When you bind, you do not. When there is no pipe, you cannot write messages (ØMQ will return <code class="literal">EAGAIN</code>).</p><p>Developers who study ØMQ and then try to create N-to-N connections between sets of equal peers often try a ROUTER-to-ROUTER flow. It's obvious why: each peer needs to address a set of peers, which requires ROUTER. It usually ends with a plaintive email to the list.</p><p>Experience teaches us that ROUTER-to-ROUTER is particularly difficult to use successfully. At a minimum, one peer must bind and one must connect, meaning the architecture is not symmetrical. But also because you simply can't tell when you are allowed to safely send a message to a peer. It's a Catch-22: you can talk to a peer after it's talked to you, but the peer can't talk to you until you've talked to it. One side or the other will be losing messages and thus has to retry, which means the peers cannot be equal.</p><p>I'm going to explain the Harmony pattern, which solves this problem, and which we use in Zyre.</p><p>We want a guarantee that when a peer "appears" on our network, we can talk to it safely without ØMQ dropping messages. For this, we have to use a DEALER or PUSH socket that <span class="emphasis"><em>connects out to the peer</em></span> so that even if that connection takes some non-zero time, there is immediately a pipe and ØMQ will accept outgoing messages.</p><p>A DEALER socket cannot address multiple peers individually. But if we have one DEALER per peer, and we connect that DEALER to the peer, we can safely send messages to a peer as soon as we've connected to it.</p><p>Now, the next problem is to know who sent us a particular message. We need a reply address that is the UUID of the node who sent any given message. DEALER can't do this unless we prefix every single message with that 16-byte UUID, which would be wasteful. ROUTER does do it if we set the identity properly before connecting to the router.</p><p>And so the Harmony pattern comes down to these components:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>One ROUTER socket that we bind to a ephemeral port, which we broadcast in our beacons.</p></li><li class="listitem"><p>One DEALER socket <span class="emphasis"><em>per peer</em></span> that we connect to the peer's ROUTER socket.</p></li><li class="listitem"><p>Reading from our ROUTER socket.</p></li><li class="listitem"><p>Writing to the peer's DEALER socket.</p></li></ul></div><p>The next problem is that discovery isn't neatly synchronized. We can get the first beacon from a peer <span class="emphasis"><em>after</em></span> we start to receive messages from it. A message comes in on the ROUTER socket and has a nice UUID attached to it, but no physical IP address and port. We have to force discovery over TCP. To do this, our first command to any new peer to which we connect is an <code class="literal">OHAI</code> command with our IP address and port. This ensure that the receiver connects back to us before trying to send us any command.</p><p>Here it is, broken down into steps:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>If we receive a UDP beacon from a new peer, we connect to the peer through a DEALER socket.</p></li><li class="listitem"><p>We read messages from our ROUTER socket, and each message comes with the UUID of the sender.</p></li><li class="listitem"><p>If it's an <code class="literal">OHAI</code> message, we connect back to that peer if not already connected to it.</p></li><li class="listitem"><p>If it's any other message, we <span class="emphasis"><em>must</em></span> already be connected to the peer (a good place for an assertion).</p></li><li class="listitem"><p>We send messages to each peer using the per-peer DEALER socket, which <span class="emphasis"><em>must</em></span> be connected.</p></li><li class="listitem"><p>When we connect to a peer, we also tell our application that the peer exists.</p></li><li class="listitem"><p>Every time we get a message from a peer, we treat that as a heartbeat (it's alive).</p></li></ul></div><p>If we were not using UDP but some other discovery mechanism, I'd still use the Harmony pattern for a true peer network: one ROUTER for input from all peers, and one DEALER per peer for output. Bind the ROUTER, connect the DEALER, and start each conversation with an <code class="literal">OHAI</code> equivalent that provides the return IP address and port. You would need some external mechanism to bootstrap each connection.</p></div><div class="sect2" title="Detecting Disappearances"><div class="titlepage"><div><div><h3 class="title"><a id="idp21343592"></a>Detecting Disappearances</h3></div></div></div><p>Heartbeating sounds simple but it's not. UDP packets get dropped when there's a lot of TCP traffic, so if we depend on UDP beacons, we'll get false disconnections. TCP traffic can be delayed for 5, 10, even 30 seconds if the network is really busy. So if we kill peers when they go quiet, we'll have false disconnections.</p><p>Because UDP beacons aren't reliable, it's tempting to add in TCP beacons. After all, TCP will deliver them reliably. However, there's one little problem. Imagine that you have 100 nodes on a network, and each node sends a TCP beacon once a second. Each beacon is 22 bytes, not counting TCP's framing overhead. That is 100 * 99 * 22 bytes per second, or 217,000 bytes/second just for heartbeating. That's about 1-2% of a typical WiFi network's ideal capacity, which sounds OK. But when a network is stressed or fighting other networks for airspace, that extra 200K a second will break what's left. UDP broadcasts are at least low cost.</p><p>So what we do is switch to TCP heartbeats only when a specific peer hasn't sent us any UDP beacons in a while. And then we send TCP heartbeats only to that one peer. If the peer continues to be silent, we conclude it's gone away. If the peer comes back with a different IP address and/or port, we have to disconnect our DEALER socket and reconnect to the new port.</p><p>This gives us a set of states for each peer, though at this stage the code doesn't use a formal state machine:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Peer visible thanks to UDP beacon (we connect using IP address and port from beacon)</p></li><li class="listitem"><p>Peer visible thanks to <code class="literal">OHAI</code> command (we connect using IP address and port from command)</p></li><li class="listitem"><p>Peer seems alive (we got a UDP beacon or command over TCP recently)</p></li><li class="listitem"><p>Peer seems quiet (no activity in some time, so we send a <code class="literal">HUGZ</code> command)</p></li><li class="listitem"><p>Peer has disappeared (no reply to our <code class="literal">HUGZ</code> commands, so we destroy peer)</p></li></ul></div><p>There's one remaining scenario we didn't address in the code at this stage. It's possible for a peer to change IP addresses and ports without actually triggering a disappearance event. For example, if the user switches off WiFi and then switches it back on, the access point can assign the peer a new IP address. We'll need to handle a disappeared WiFi interface on our node by unbinding the ROUTER socket and rebinding it when we can. Because this is not central to the design now, I decide to log an issue on the GitHub tracker and leave it for a rainy day.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch08s04.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch08.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch08s06.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Spinning Off a Library Project </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Group Messaging</td></tr></table></div></body></html>
