<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 3. Advanced Request-Reply Patterns</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="prev" href="ch02s12.html" title="Missing Message Problem Solver" /><link rel="next" href="ch03s02.html" title="Request-Reply Combinations" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 3. Advanced Request-Reply Patterns</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch02s12.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch03s02.html">Next</a></td></tr></table><hr /></div><div class="chapter" title="Chapter 3. Advanced Request-Reply Patterns"><div class="titlepage"><div><div><h2 class="title"><a id="advanced-request-reply"></a>Chapter 3. Advanced Request-Reply Patterns</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="sect1"><a href="ch03.html#idp19364168">The Request-Reply Mechanisms</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch03.html#idp19366232">The Simple Reply Envelope</a></span></dt><dt><span class="sect2"><a href="ch03.html#idp19371520">The Extended Reply Envelope</a></span></dt><dt><span class="sect2"><a href="ch03.html#idp19387672">What's This Good For?</a></span></dt><dt><span class="sect2"><a href="ch03.html#idp19391160">Recap of Request-Reply Sockets</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch03s02.html">Request-Reply Combinations</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch03s02.html#idp19399632">The REQ to REP Combination</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#idp19401000">The DEALER to REP Combination</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#idp19404336">The REQ to ROUTER Combination</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#idp19407664">The DEALER to ROUTER Combination</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#idp19409072">The DEALER to DEALER Combination</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#idp19410424">The ROUTER to ROUTER Combination</a></span></dt><dt><span class="sect2"><a href="ch03s02.html#idp19411920">Invalid Combinations</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch03s03.html">Exploring ROUTER Sockets</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch03s03.html#idp19416472">Identities and Addresses</a></span></dt><dt><span class="sect2"><a href="ch03s03.html#idp19425000">ROUTER Error Handling</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch03s04.html">The Load Balancing Pattern</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch03s04.html#idp19432240">ROUTER Broker and REQ Workers</a></span></dt><dt><span class="sect2"><a href="ch03s04.html#idp19442024">ROUTER Broker and DEALER Workers</a></span></dt><dt><span class="sect2"><a href="ch03s04.html#idp19448296">A Load Balancing Message Broker</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch03s05.html">A High-Level API for ØMQ</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch03s05.html#idp19490664">Features of a Higher-Level API</a></span></dt><dt><span class="sect2"><a href="ch03s05.html#idp19498192">The CZMQ High-Level API</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch03s06.html">The Asynchronous Client/Server Pattern</a></span></dt><dt><span class="sect1"><a href="ch03s07.html">Worked Example: Inter-Broker Routing</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch03s07.html#idp19553104">Establishing the Details</a></span></dt><dt><span class="sect2"><a href="ch03s07.html#idp19559848">Architecture of a Single Cluster</a></span></dt><dt><span class="sect2"><a href="ch03s07.html#idp19562680">Scaling to Multiple Clusters</a></span></dt><dt><span class="sect2"><a href="ch03s07.html#idp19576264">Federation Versus Peering</a></span></dt><dt><span class="sect2"><a href="ch03s07.html#idp19583256">The Naming Ceremony</a></span></dt><dt><span class="sect2"><a href="ch03s07.html#idp19595632">Prototyping the State Flow</a></span></dt><dt><span class="sect2"><a href="ch03s07.html#idp19611720">Prototyping the Local and Cloud Flows</a></span></dt><dt><span class="sect2"><a href="ch03s07.html#idp19641400">Putting it All Together</a></span></dt></dl></dd></dl></div><p>In Sockets and Patterns<a class="xref" href="ch02.html" title="Chapter 2. Sockets and Patterns">Chapter 2, <em>Sockets and Patterns</em></a> we worked through the basics of using ØMQ by developing a series of small applications, each time exploring new aspects of ØMQ. We'll continue this approach in this chapter as we explore advanced patterns built on top of ØMQ's core request-reply pattern.</p><p>We'll cover:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>How the request-reply mechanisms work</p></li><li class="listitem"><p>How to combine REQ, REP, DEALER, and ROUTER sockets</p></li><li class="listitem"><p>How ROUTER sockets work, in detail</p></li><li class="listitem"><p>The load balancing pattern</p></li><li class="listitem"><p>Building a simple load balancing message broker</p></li><li class="listitem"><p>Designing a high-level API for ØMQ</p></li><li class="listitem"><p>Building an asynchronous request-reply server</p></li><li class="listitem"><p>A detailed inter-broker routing example</p></li></ul></div><div class="sect1" title="The Request-Reply Mechanisms"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp19364168"></a>The Request-Reply Mechanisms</h2></div></div></div><p>We already looked briefly at multipart messages. Let's now look at a major use case, which is <span class="emphasis"><em>reply message envelopes</em></span>. An envelope is a way of safely packaging up data with an address, without touching the data itself. By separating reply addresses into an envelope we make it possible to write general purpose intermediaries such as APIs and proxies that create, read, and remove addresses no matter what the message payload or structure is.</p><p>In the request-reply pattern, the envelope holds the return address for replies. It is how a ØMQ network with no state can create round-trip request-reply dialogs.</p><p>When you use REQ and REP sockets you don't even see envelopes; these sockets deal with them automatically. But for most of the interesting request-reply patterns, you'll want to understand envelopes and particularly ROUTER sockets. We'll work through this step-by-step.</p><div class="sect2" title="The Simple Reply Envelope"><div class="titlepage"><div><div><h3 class="title"><a id="idp19366232"></a>The Simple Reply Envelope</h3></div></div></div><p>A request-reply exchange consists of a <span class="emphasis"><em>request</em></span> message, and an eventual <span class="emphasis"><em>reply</em></span> message. In the simple request-reply pattern, there's one reply for each request. In more advanced patterns, requests and replies can flow asynchronously. However, the reply envelope always works the same way.</p><p>The ØMQ reply envelope formally consists of zero or more reply addresses, followed by an empty frame (the envelope delimiter), followed by the message body (zero or more frames). The envelope is created by multiple sockets working together in a chain. We'll break this down.</p><p>We'll start by sending "Hello" through a REQ socket. The REQ socket creates the simplest possible reply envelope, which has no addresses, just an empty delimiter frame and the message frame containing the "Hello" string. This is a two-frame message<a class="xref" href="ch03.html#figure-26" title="Figure 3.1. Request with Minimal Envelope">Figure 3.1, “Request with Minimal Envelope”</a>.</p><div class="figure"><a id="figure-26"></a><p class="title"><strong>Figure 3.1. Request with Minimal Envelope</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/fig26.png" alt="Request with Minimal Envelope" /></div></div></div><br class="figure-break" /><p>The REP socket does the matching work: it strips off the envelope, up to and including the delimiter frame, saves the whole envelope, and passes the "Hello" string up the application. Thus our original Hello World example used request-reply envelopes internally, but the application never saw them.</p><p>If you spy on the network data flowing between <code class="literal">hwclient</code> and <code class="literal">hwserver</code>, this is what you'll see: every request and every reply is in fact two frames, an empty frame and then the body. It doesn't seem to make much sense for a simple REQ-REP dialog. However you'll see the reason when we explore how ROUTER and DEALER handle envelopes.</p></div><div class="sect2" title="The Extended Reply Envelope"><div class="titlepage"><div><div><h3 class="title"><a id="idp19371520"></a>The Extended Reply Envelope</h3></div></div></div><p>Now let's extend the REQ-REP pair with a ROUTER-DEALER proxy in the middle and see how this affects the reply envelope. This is the <span class="emphasis"><em>extended request-reply pattern</em></span> we already saw in Sockets and Patterns<a class="xref" href="ch02.html" title="Chapter 2. Sockets and Patterns">Chapter 2, <em>Sockets and Patterns</em></a>. We can, in fact, insert any number of proxy steps<a class="xref" href="ch03.html#figure-27" title="Figure 3.2. Extended Request-Reply Pattern">Figure 3.2, “Extended Request-Reply Pattern”</a>. The mechanics are the same.</p><div class="figure"><a id="figure-27"></a><p class="title"><strong>Figure 3.2. Extended Request-Reply Pattern</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/fig27.png" alt="Extended Request-Reply Pattern" /></div></div></div><br class="figure-break" /><p>The proxy does this, in pseudo-code:</p><pre class="screen">prepare context, frontend and backend sockets
while true:
    poll on both sockets
    if frontend had input:
        read all frames from frontend
        send to backend
    if backend had input:
        read all frames from backend
        send to frontend
</pre><p>The ROUTER socket, unlike other sockets, tracks every connection it has, and tells the caller about these. The way it tells the caller is to stick the connection <span class="emphasis"><em>identity</em></span> in front of each message received. An identity, sometimes called an <span class="emphasis"><em>address</em></span>, is just a binary string with no meaning except "this is a unique handle to the connection". Then, when you send a message via a ROUTER socket, you first send an identity frame.</p><p>The <code class="literal">zmq_socket()</code> man page describes it thus:</p><div class="blockquote"><blockquote class="blockquote"><p>When receiving messages a ZMQ_ROUTER socket shall prepend a message part containing the identity of the originating peer to the message before passing it to the application. Messages received are fair-queued from among all connected peers. When sending messages a ZMQ_ROUTER socket shall remove the first part of the message and use it to determine the identity of the peer the message shall be routed to.</p></blockquote></div><p>As a historical note, ØMQ v2.2 and earlier use UUIDs as identities, and ØMQ v3.0 and later use short integers. There's some impact on network performance, but only when you use multiple proxy hops, which is rare. Mostly the change was to simplify building <code class="literal">libzmq</code> by removing the dependency on a UUID library.</p><p>Identies are a difficult concept to understand, but it's essential if you want to become a ØMQ expert. The ROUTER socket <span class="emphasis"><em>invents</em></span> a random identity for each connection with which it works. If there are three REQ sockets connected to a ROUTER socket, it will invent three random identities, one for each REQ socket.</p><p>So if we continue our worked example, let's say the REQ socket has a 3-byte identity <code class="literal">ABC</code>. Internally, this means the ROUTER socket keeps a hash table where it can search for <code class="literal">ABC</code> and find the TCP connection for the REQ socket.</p><p>When we receive the message off the ROUTER socket, we get three frames<a class="xref" href="ch03.html#figure-28" title="Figure 3.3. Request with One Address">Figure 3.3, “Request with One Address”</a>.</p><div class="figure"><a id="figure-28"></a><p class="title"><strong>Figure 3.3. Request with One Address</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/fig28.png" alt="Request with One Address" /></div></div></div><br class="figure-break" /><p>The core of the proxy loop is "read from one socket, write to the other", so we literally send these three frames out on the DEALER socket. If you now sniffed the network traffic, you would see these three frames flying from the DEALER socket to the REP socket. The REP socket does as before, strips off the whole envelope including the new reply address, and once again delivers the "Hello" to the caller.</p><p>Incidentally the REP socket can only deal with one request-reply exchange at a time, which is why if you try to read multiple requests or send multiple replies without sticking to a strict recv-send cycle, it gives an error.</p><p>You should now be able to visualize the return path. When <code class="literal">hwserver</code> sends "World" back, the REP socket wraps that with the envelope it saved, and sends a three-frame reply message across the wire to the DEALER socket<a class="xref" href="ch03.html#figure-29" title="Figure 3.4. Reply with one Address">Figure 3.4, “Reply with one Address”</a>.</p><div class="figure"><a id="figure-29"></a><p class="title"><strong>Figure 3.4. Reply with one Address</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/fig29.png" alt="Reply with one Address" /></div></div></div><br class="figure-break" /><p>Now the DEALER reads these three frames, and sends all three out via the ROUTER socket. The ROUTER takes the first frame for the message, which is the <code class="literal">ABC</code> identity, and looks up the connection for this. If it finds that, it then pumps the next two frames out onto the wire<a class="xref" href="ch03.html#figure-30" title="Figure 3.5. Reply with Minimal Envelope">Figure 3.5, “Reply with Minimal Envelope”</a>.</p><div class="figure"><a id="figure-30"></a><p class="title"><strong>Figure 3.5. Reply with Minimal Envelope</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/fig30.png" alt="Reply with Minimal Envelope" /></div></div></div><br class="figure-break" /><p>The REQ socket picks this message up, and checks that the first frame is the empty delimiter, which it is. The REQ socket discards that frame and passes "World" to the calling application, which prints it out to the amazement of the younger us looking at ØMQ for the first time.</p></div><div class="sect2" title="What's This Good For?"><div class="titlepage"><div><div><h3 class="title"><a id="idp19387672"></a>What's This Good For?</h3></div></div></div><p>To be honest, the use cases for strict request-reply or extended request-reply are somewhat limited. For one thing, there's no easy way to recover from common failures like the server crashing due to buggy application code. We'll see more about this in Reliable Request-Reply Patterns<a class="xref" href="ch04.html" title="Chapter 4. Reliable Request-Reply Patterns">Chapter 4, <em>Reliable Request-Reply Patterns</em></a>. However once you grasp the way these four sockets deal with envelopes, and how they talk to each other, you can do very useful things. We saw how ROUTER uses the reply envelope to decide which client REQ socket to route a reply back to. Now let's express this another way:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Each time ROUTER gives you a message, it tells you what peer that came from, as an identity.</p></li><li class="listitem"><p>You can use this with a hash table (with the identity as key) to track new peers as they arrive.</p></li><li class="listitem"><p>ROUTER will route messages asynchronously to any peer connected to it, if you prefix the identity as the first frame of the message.</p></li></ul></div><p>ROUTER sockets don't care about the whole envelope. They don't know anything about the empty delimiter. All they care about is that one identity frame that lets them figure out which connection to send a message to.</p></div><div class="sect2" title="Recap of Request-Reply Sockets"><div class="titlepage"><div><div><h3 class="title"><a id="idp19391160"></a>Recap of Request-Reply Sockets</h3></div></div></div><p>Let's recap this:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The REQ socket sends, to the network, an empty delimiter frame in front of the message data. REQ sockets are synchronous. REQ sockets always send one request and then wait for one reply. REQ sockets talk to one peer at a time. If you connect a REQ socket to multiple peers, requests are distributed to and replies expected from each peer one turn at a time.</p></li><li class="listitem"><p>The REP socket reads and saves all identity frames up to and including the empty delimiter, then passes the following frame or frames to the caller. REP sockets are synchronous and talk to one peer at a time. If you connect a REP socket to multiple peers, requests are read from peers in fair fashion, and replies are always sent to the same peer that made the last request.</p></li><li class="listitem"><p>The DEALER socket is oblivious to the reply envelope and handles this like any multipart message. DEALER sockets are asynchronous and like PUSH and PULL combined. They distribute sent messages among all connections, and fair-queue received messages from all connections.</p></li><li class="listitem"><p>The ROUTER socket is oblivious to the reply envelope, like DEALER. It creates identities for its connections, and passes these identities to the caller as a first frame in any received message. Conversely, when the caller sends a message, it use the first message frame as an identity to look up the connection to send to. ROUTERS are asynchronous.</p></li></ul></div></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch02s12.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch03s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Missing Message Problem Solver </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Request-Reply Combinations</td></tr></table></div></body></html>
