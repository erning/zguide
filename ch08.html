<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 8. A Framework for Distributed Computing</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="prev" href="ch07s08.html" title="Getting an Official Port Number" /><link rel="next" href="ch08s02.html" title="The Secret Life of WiFi" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 8. A Framework for Distributed Computing</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch07s08.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch08s02.html">Next</a></td></tr></table><hr /></div><div class="chapter" title="Chapter 8. A Framework for Distributed Computing"><div class="titlepage"><div><div><h2 class="title"><a id="moving-pieces"></a>Chapter 8. A Framework for Distributed Computing</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="sect1"><a href="ch08.html#idp21136288">Design for The Real World</a></span></dt><dt><span class="sect1"><a href="ch08s02.html">The Secret Life of WiFi</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch08s02.html#idp21144824">Why Mesh Isn't Here Yet</a></span></dt><dt><span class="sect2"><a href="ch08s02.html#idp21150416">Some Physics</a></span></dt><dt><span class="sect2"><a href="ch08s02.html#idp21154936">What's the Current Status?</a></span></dt><dt><span class="sect2"><a href="ch08s02.html#idp15556944">Conclusions</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch08s03.html">Discovery</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch08s03.html#idp15560472">Service Discovery</a></span></dt><dt><span class="sect2"><a href="ch08s03.html#idp15567624">Network Discovery</a></span></dt><dt><span class="sect2"><a href="ch08s03.html#idp21199400">The Use Case</a></span></dt><dt><span class="sect2"><a href="ch08s03.html#idp21209824">Technical Requirements</a></span></dt><dt><span class="sect2"><a href="ch08s03.html#idp21216856">A Self-Healing P2P Network in 30 Seconds</a></span></dt><dt><span class="sect2"><a href="ch08s03.html#idp21226160">Preemptive Discovery over Raw Sockets</a></span></dt><dt><span class="sect2"><a href="ch08s03.html#idp21238648">Cooperative Discovery Using UDP Broadcasts</a></span></dt><dt><span class="sect2"><a href="ch08s03.html#idp21257040">Multiple Nodes on One Device</a></span></dt><dt><span class="sect2"><a href="ch08s03.html#idp21261416">Designing the API</a></span></dt><dt><span class="sect2"><a href="ch08s03.html#idp21302864">More About UDP</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch08s04.html">Spinning Off a Library Project</a></span></dt><dt><span class="sect1"><a href="ch08s05.html">Point-to-Point Messaging</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch08s05.html#idp21321312">UDP Beacon Framing</a></span></dt><dt><span class="sect2"><a href="ch08s05.html#idp21330872">True Peer Connectivity (Harmony Pattern)</a></span></dt><dt><span class="sect2"><a href="ch08s05.html#idp21343592">Detecting Disappearances</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch08s06.html">Group Messaging</a></span></dt><dt><span class="sect1"><a href="ch08s07.html">Testing and Simulation</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch08s07.html#idp21369536">On Assertions</a></span></dt><dt><span class="sect2"><a href="ch08s07.html#idp21374256">On Up-Front Testing</a></span></dt><dt><span class="sect2"><a href="ch08s07.html#idp21379512">The Zyre Tester</a></span></dt><dt><span class="sect2"><a href="ch08s07.html#idp21394528">Test Results</a></span></dt><dt><span class="sect2"><a href="ch08s07.html#idp21413160">Tracing Activity</a></span></dt><dt><span class="sect2"><a href="ch08s07.html#idp21416280">Dealing with Blocked Peers</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch08s08.html">Distributed Logging and Monitoring</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch08s08.html#idp21437200">A Plausible Minimal Implementation</a></span></dt><dt><span class="sect2"><a href="ch08s08.html#idp21458192">Protocol Assertions</a></span></dt><dt><span class="sect2"><a href="ch08s08.html#idp21465368">Binary Logging Protocol</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch08s09.html">Content Distribution</a></span></dt><dt><span class="sect1"><a href="ch08s10.html">Writing the Unprotocol</a></span></dt><dt><span class="sect1"><a href="ch08s11.html">Example Zyre Application</a></span></dt><dt><span class="sect1"><a href="ch08s12.html">Conclusions</a></span></dt></dl></div><p>We've gone though a journey of understanding ØMQ in its many aspects. By now you may have started to build your own products using the techniques I explained, as well as others you've figured out yourself. You will start to face questions about how to make these products work in the real world.</p><p>But what is that "real world"? I'll argue that it is becoming a world of ever increasing numbers of moving pieces. Some people use the phrase the "Internet of Things", suggesting that we'll see a new category of devices that are more numerous but also more stupid than our current smart phones, tablets, laptops, and servers. However, I don't think the data points this way at all. Yes, there are more and more devices, but they're not stupid at all. They're smart and powerful and getting more so all the time.</p><p>The mechanism at work is something I call "Cost Gravity" and it has the effect of reducing the cost of technology by half every 18-24 months. Put another way, our global computing capacity doubles every two years, over and over and over. The future is filled with trillions of devices that are fully powerful multi-core computers: they don't run a cut-down "operating system for things" but full operating systems and full applications.</p><p>And this is the world we're targeting with ØMQ. When we talk of "scale", we don't mean hundreds of computers, or even thousands. Think of clouds of tiny smart and perhaps self-replicating machines surrounding every person, filling every space, covering every wall, filling the cracks and eventually, becoming so much a part of us that we get them before birth and they follow us to death.</p><p>These clouds of tiny machines talk to each other, all the time, over short-range wireless links using the Internet Protocol. They create mesh networks, pass information and tasks around like nervous signals. They augment our memory, vision, every aspect of our communications, and physical functions. And it's ØMQ that powers their conversations and events and exchanges of work and information.</p><p>Now, to make even a thin imitation of this come true today, we need to solve a set of technical problems. These include: How do peers discover each other? How do they talk to existing networks like the Web? How do they protect the information they carry? How do we track and monitor them, to get some idea of what they're doing? Then we need to do what most engineers forget about: package this solution into a framework that is dead easy for ordinary developers to use.</p><p>This is what we'll attempt in this chapter: to build a framework for distributed applications as an API, protocols, and implementations. It's not a small challenge but I've claimed often that ØMQ makes such problems simple, so let's see if that's still true.</p><p>We'll cover:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Requirements for distributed computing</p></li><li class="listitem"><p>The pros and cons of WiFi for proximity networking</p></li><li class="listitem"><p>Discovery using UDP and TCP</p></li><li class="listitem"><p>A message-based API</p></li><li class="listitem"><p>Creating a new open source project</p></li><li class="listitem"><p>Peer-to-peer connectivity (the Harmony pattern)</p></li><li class="listitem"><p>Tracking peer presence and disappearance</p></li><li class="listitem"><p>Group messaging without central coordination</p></li><li class="listitem"><p>Large-scale testing and simulation</p></li><li class="listitem"><p>Dealing with high-water marks and blocked peers</p></li><li class="listitem"><p>Distributed logging and monitoring</p></li></ul></div><div class="sect1" title="Design for The Real World"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp21136288"></a>Design for The Real World</h2></div></div></div><p>Whether we're connecting a roomful of mobile devices over WiFi or a cluster of virtual boxes over simulated Ethernet, we will hit the same kinds of problems. These are:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em>Discovery</em></span>: how do we learn about other nodes on the network? Do we use a discovery service, centralized mediation, or some kind of broadcast beacon?</p></li><li class="listitem"><p><span class="emphasis"><em>Presence</em></span>: how do we track when other nodes come and go? Do we use some kind of central registration service, or heartbeating or beacons?</p></li><li class="listitem"><p><span class="emphasis"><em>Connectivity</em></span>: how do we actually connect one node to another? Do we use local networking, wide-area networking, or do we use a central message broker to do the forwarding?</p></li><li class="listitem"><p><span class="emphasis"><em>Point-to-point messaging</em></span>: how do we send a message from one node to another? Do we send this to the node's network address, or do we use some indirect addressing via a centralized message broker?</p></li><li class="listitem"><p><span class="emphasis"><em>Group messaging</em></span>: how do we send a message from one node to a group of others? Do we work via a centralized message broker, or do we use a pub-sub model like ØMQ?</p></li><li class="listitem"><p><span class="emphasis"><em>Testing and simulation</em></span>: how do we simulate large numbers of nodes so we can test performance properly? Do we have to buy two dozen Android tablets, or can we use pure software simulation?</p></li><li class="listitem"><p><span class="emphasis"><em>Distributed Logging</em></span>: how do we track what this cloud of nodes is doing so we can detect performance problems and failures? Do we create a main logging service, or do we allow every device to log the world around it?</p></li><li class="listitem"><p><span class="emphasis"><em>Content distribution</em></span>: how do we send content from one node to another? Do we use server-centric protocols like FTP or HTTP, or do we use decentralized protocols like FileMQ?</p></li></ul></div><p>If we can solve these problems reasonably well, and the further problems that will emerge (like security and wide-area bridging), we get something like a framework for what I might call "Really Cool Distributed Applications", or as my grandkids call it, "the software our world runs on".</p><p>You should have guessed from my rhetorical questions that there are two broad directions in which we can go. One is to centralize everything. The other is to distribute everything. I'm going to bet on decentralization. If you want centralization, you don't really need ØMQ; there are other options you can use.</p><p>So very roughly, here's the story. One, the number of moving pieces increases exponentially over time (doubles every 24 months). Two, these pieces stop using wires because dragging cables everywhere gets <span class="emphasis"><em>really</em></span> boring. Three, future applications run across clusters of these pieces using the Benevolent Tyrant pattern from The ØMQ Community<a class="xref" href="ch06.html" title="Chapter 6. The ØMQ Community">Chapter 6, <em>The ØMQ Community</em></a>. Four, today it's really difficult, nay still rather impossible, to build such applications. Five, let's make it cheap and easy using all the techniques and tools we've built up. Six, partay!</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch07s08.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch08s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Getting an Official Port Number </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> The Secret Life of WiFi</td></tr></table></div></body></html>
