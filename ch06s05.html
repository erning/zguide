<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Git Branches Considered Harmful</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="ch06.html" title="Chapter 6. The ØMQ Community" /><link rel="prev" href="ch06s04.html" title="A Real-Life Example" /><link rel="next" href="ch06s06.html" title="Designing for Innovation" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Git Branches Considered Harmful</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch06s04.html">Prev</a> </td><th width="60%" align="center">Chapter 6. The ØMQ Community</th><td width="20%" align="right"> <a accesskey="n" href="ch06s06.html">Next</a></td></tr></table><hr /></div><div class="sect1" title="Git Branches Considered Harmful"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp20716424"></a>Git Branches Considered Harmful</h2></div></div></div><p>One of git's most popular features is its branches. Almost all projects that use git use branches, and the selection of the "best" branching strategy is like a rite of passage for an open source project. Vincent Driessen's <a class="ulink" href="http://nvie.com/posts/a-successful-git-branching-model/" target="_top">git-flow</a> may be the best known. It has <span class="emphasis"><em>base</em></span> branches (master, develop), <span class="emphasis"><em>feature</em></span> branches, <span class="emphasis"><em>release</em></span> branches, <span class="emphasis"><em>hotfix</em></span> branches, and <span class="emphasis"><em>support</em></span> branches. Many teams have adopted git-flow, which even has git extensions to support it. I'm a great believer in popular wisdom, but sometimes you have to recognize mass delusion for what it is.</p><p>Here is a section of C4 that might have shocked you when you first read it:</p><div class="blockquote"><blockquote class="blockquote"><p>The project SHALL NOT use topic branches for any reason. Personal forks MAY use topic branches.</p></blockquote></div><p>To be clear, it's <span class="emphasis"><em>public branches in shared repositories</em></span> that I'm talking about. Using branches for private work, e.g., to work on different issues, appears to work well enough, though it's more complexity than I personally enjoy. To channel Stallman again: "your freedom to create complexity ends one inch from our shared workspace."</p><p>Like the rest of C4, the rules on branches are not accidental. They came from our experience making ØMQ, starting when Martin Sustrik and I rethought how to make stable releases. We both love and appreciate simplicity (some people seem to have a remarkable tolerance for complexity). We chatted for a while... I asked him, "I'm going to start making a stable release. Would it be OK for me to make a branch in the git you're working in?" Martin didn't like the idea. "OK, if I fork the repository, I can move patches from your repo to that one". That felt much better to both of us.</p><p>The response from many in the ØMQ community was shock and horror. People felt we were being lazy and making contributors work harder to find the "right" repository. Still, this seemed simple, and indeed it worked smoothly. The best part was that we each worked as we wanted to. Whereas before, the ØMQ repository had felt horribly complex (and it wasn't even anything like git-flow), this felt simple. And it worked. The only downside was that we lost a single unified history. Now, perhaps historians will feel robbed, but I honestly can't see that the historical minutiae of who changed what, when, including every branch and experiment, are worth any significant pain or friction.</p><p>People have gotten used to the "multiple repositories" approach in ZeroMQ and we've started using that in other projects quite successfully. My own opinion is that history will judge git branches and patterns like git-flow as a complex solution to imaginary problems inherited from the days of Subversion and monolithic repositories.</p><p>More profoundly, and perhaps this is why the majority seems to be "wrong": I think the the branches versus forks argument is really a deeper design versus evolve argument about how to make software optimally. I'll address that deeper argument in the next section. For now, I'll try to be scientific about my irrational hatred of branches, by looking at a number of criteria, and comparing branches and forks in each one.</p><div class="sect2" title="Simplicity Versus Complexity"><div class="titlepage"><div><div><h3 class="title"><a id="idp20723184"></a>Simplicity Versus Complexity</h3></div></div></div><p><span class="emphasis"><em>The simpler, the better.</em></span></p><p>There is no inherent reason why branches are more complex than forks. However, git-flow uses <span class="emphasis"><em>five types</em></span> of branch, whereas C4 uses two types of fork (development, and stable) and one branch (master). Circumstantial evidence is thus that branches lead to more complexity than forks. For new users, it is definitely, and we've measured this in practice, easier to learn to work with many repositories and no branches except master.</p></div><div class="sect2" title="Change Latency"><div class="titlepage"><div><div><h3 class="title"><a id="idp20724688"></a>Change Latency</h3></div></div></div><p><span class="emphasis"><em>The smaller and more rapid the delivery, the better.</em></span></p><p>Development branches seem to correlate strongly with large, slow, risky deliveries. "Sorry, I have to merge this branch before we can test the new version" signals a breakdown in process. It's certainly not how C4 works, which is by focusing tightly on individual problems and their minimal solutions. Allowing branches in development raises change latency. Forks have a different outcome: it's up to the forker to ensure that his changes merge cleanly, and to keep them simple so they won't be rejected.</p></div><div class="sect2" title="Learning Curve"><div class="titlepage"><div><div><h3 class="title"><a id="idp20726096"></a>Learning Curve</h3></div></div></div><p><span class="emphasis"><em>The smoother the learning curve, the better.</em></span></p><p>Evidence definitely shows that learning to use git branches is complex. For some people, this is OK. For most developers, every cycle spent learning git is a cycle lost on more productive things. I've been told several times, by different people that I do not like branches because I "never properly learned git". That is fair, but it is a criticism of the tool, not the human.</p></div><div class="sect2" title="Cost of Failure"><div class="titlepage"><div><div><h3 class="title"><a id="idp20727368"></a>Cost of Failure</h3></div></div></div><p><span class="emphasis"><em>The lower the cost of failure, the better.</em></span></p><p>Branches demand more perfection from developers because mistakes potentially affect others. This raises the cost of failure. Forks make failure extremely cheap because literally nothing that happens in a fork can affect others not using that fork.</p></div><div class="sect2" title="Up-front Coordination"><div class="titlepage"><div><div><h3 class="title"><a id="idp20728456"></a>Up-front Coordination</h3></div></div></div><p><span class="emphasis"><em>The less need for up-front coordination, the better.</em></span></p><p>You can do a hostile fork. You cannot do a hostile branch. Branches depend on up-front coordination, which is expensive and fragile. One person can veto the desires of a whole group. For example in the ØMQ community we were unable to agree on a git branching model for a year. We solved that by using forking instead. The problem went away.</p></div><div class="sect2" title="Scalability"><div class="titlepage"><div><div><h3 class="title"><a id="idp20729288"></a>Scalability</h3></div></div></div><p><span class="emphasis"><em>The more you can scale a project, the better.</em></span></p><p>The strong assumption in all branch strategies is that the repository <span class="emphasis"><em>is</em></span> the project. But there is a limit to how many people you can get to agree to work together in one repository. As I explained, the cost of up-front coordination can become fatal. A more realistic project scales by allowing anyone to start their own repositories, and ensuring these can work together. A project like ØMQ has dozens of repositories. Forking looks more scalable than branching.</p></div><div class="sect2" title="Surprise and Expectations"><div class="titlepage"><div><div><h3 class="title"><a id="idp20730816"></a>Surprise and Expectations</h3></div></div></div><p><span class="emphasis"><em>The less surprising, the better.</em></span></p><p>People expect branches and find forks to be uncommon and thus confusing. This is the one aspect where branches win. If you use branches, a single patch will have the same commit hash tag, whereas across forks the patch will have different hash tags. That makes it harder to track patches as they cross forks, true. But seriously, <span class="emphasis"><em>having to track hexadecimal hash tags is not a feature</em></span>. It's a bug. Sometimes better ways of working are surprising at first.</p></div><div class="sect2" title="Economics of Participation"><div class="titlepage"><div><div><h3 class="title"><a id="idp20732832"></a>Economics of Participation</h3></div></div></div><p><span class="emphasis"><em>The more tangible the rewards, the better.</em></span></p><p>People like to own their work and get credit for it. This is much easier with forks than with branches. Forks create more competition in a healthy way, while branches suppress competition and force people to collaborate and share credit. This sounds positive but in my experience it demotivates people. A branch isn't a product you can "own", whereas a fork can be.</p></div><div class="sect2" title="Robustness in Conflict"><div class="titlepage"><div><div><h3 class="title"><a id="idp20734088"></a>Robustness in Conflict</h3></div></div></div><p><span class="emphasis"><em>The more a model can survive conflict, the better.</em></span></p><p>Like it or not, people fight over ego, status, beliefs, and theories of the world. Challenge is a necessary part of science. If your organizational model depends on agreement, you won't survive the first real fight. Branches do not survive real arguments and fights, whereas forks can be hostile, and still benefit all parties. And this is indeed how free software works.</p></div><div class="sect2" title="Guarantees of Isolation"><div class="titlepage"><div><div><h3 class="title"><a id="idp20735352"></a>Guarantees of Isolation</h3></div></div></div><p><span class="emphasis"><em>The stronger the isolation between production code and experiment, the better.</em></span></p><p>People make mistakes. I've seen experimental code pushed to mainline production by error. I've seen people make bad panic changes under stress. But the real fault is in allowing two entirely separate generations of product to exist in the same protected space. If you can push to random-branch-x, you can push to master. Branches do not guarantee isolation of production critical code. Forks do.</p></div><div class="sect2" title="Visibility"><div class="titlepage"><div><div><h3 class="title"><a id="idp20736672"></a>Visibility</h3></div></div></div><p><span class="emphasis"><em>The more visible our work, the better.</em></span></p><p>Forks have watchers, issues, a README, and a wiki. Branches have none of these. People try forks, build them, break them, patch them. Branches sit there until someone remembers to work on them. Forks have downloads and tarballs. Branches do not. When we look for self-organization, the more visible and declarative the problems, the faster and more accurately we can work.</p></div><div class="sect2" title="Conclusions"><div class="titlepage"><div><div><h3 class="title"><a id="idp20737936"></a>Conclusions</h3></div></div></div><p>In this section, I've listed a series of arguments, most of which came from fellow team members. Here's how it seems to break down: git veterans insist that branches are the way to work, whereas newcomers tend to feel intimidated when asked to navigate git branches. Git is not an easy tool to master. What we've discovered, accidentally, is that when you stop using branches <span class="emphasis"><em>at all</em></span>, git becomes trivial to use. It literally comes down to six commands (<code class="literal">clone</code>, <code class="literal">remote</code>, <code class="literal">commit</code>, <code class="literal">log</code>, <code class="literal">push</code>, and <code class="literal">pull</code>). Furthermore, a branch-free process actually works, we've used it for a couple of years now, and no visible downside except surprise to the veterans and growth of "single" projects over multiple repositories.</p><p>If you can't use forks, perhaps because your firm doesn't trust GitHub's private repositories, then you can perhaps use topic branches, one per issue. You'll still suffer the costs of getting up-front consensus, low competitiveness, and risk of human error.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch06s04.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch06.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch06s06.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">A Real-Life Example </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Designing for Innovation</td></tr></table></div></body></html>
