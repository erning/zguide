<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 7. Advanced Architecture using ØMQ</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="prev" href="ch06s08.html" title="Patterns for Success" /><link rel="next" href="ch07s02.html" title="Unprotocols" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 7. Advanced Architecture using ØMQ</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch06s08.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch07s02.html">Next</a></td></tr></table><hr /></div><div class="chapter" title="Chapter 7. Advanced Architecture using ØMQ"><div class="titlepage"><div><div><h2 class="title"><a id="advanced-architecture"></a>Chapter 7. Advanced Architecture using ØMQ</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="sect1"><a href="ch07.html#idp20828872">Message-Oriented Pattern for Elastic Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch07.html#idp20833352">Step 1: Internalize the Semantics</a></span></dt><dt><span class="sect2"><a href="ch07.html#idp20834984">Step 2: Draw a Rough Architecture</a></span></dt><dt><span class="sect2"><a href="ch07.html#idp20838736">Step 3: Decide on the Contracts</a></span></dt><dt><span class="sect2"><a href="ch07.html#idp20843312">Step 4: Write a Minimal End-to-End Solution</a></span></dt><dt><span class="sect2"><a href="ch07.html#idp20846488">Step 5: Solve One Problem and Repeat</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch07s02.html">Unprotocols</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch07s02.html#idp20848728">Protocols Without The Goats</a></span></dt><dt><span class="sect2"><a href="ch07s02.html#idp20853752">Contracts Are Hard</a></span></dt><dt><span class="sect2"><a href="ch07s02.html#idp20861960">How to Write Unprotocols</a></span></dt><dt><span class="sect2"><a href="ch07s02.html#idp20869488">Why use the GPLv3 for Public Specifications?</a></span></dt><dt><span class="sect2"><a href="ch07s02.html#idp20873984">Using ABNF</a></span></dt><dt><span class="sect2"><a href="ch07s02.html#idp20879704">The Cheap or Nasty Pattern</a></span></dt><dt><span class="sect2"><a href="ch07s02.html#idp20890824">Error Handling</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch07s03.html">Serializing Your Data</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch07s03.html#idp20893648">Abstraction Level</a></span></dt><dt><span class="sect2"><a href="ch07s03.html#idp20896328">ØMQ Framing</a></span></dt><dt><span class="sect2"><a href="ch07s03.html#idp20900008">Serialization Languages</a></span></dt><dt><span class="sect2"><a href="ch07s03.html#idp20905400">Serialization Libraries</a></span></dt><dt><span class="sect2"><a href="ch07s03.html#idp20911952">Handwritten Binary Serialization</a></span></dt><dt><span class="sect2"><a href="ch07s03.html#idp20919656">Code Generation</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch07s04.html">Transferring Files</a></span></dt><dt><span class="sect1"><a href="ch07s05.html">State Machines</a></span></dt><dt><span class="sect1"><a href="ch07s06.html">Authentication Using SASL</a></span></dt><dt><span class="sect1"><a href="ch07s07.html">Large-Scale File Publishing: FileMQ</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch07s07.html#idp21045600">Why make FileMQ?</a></span></dt><dt><span class="sect2"><a href="ch07s07.html#idp21048672">Initial Design Cut: the API</a></span></dt><dt><span class="sect2"><a href="ch07s07.html#idp21052648">Initial Design Cut: the Protocol</a></span></dt><dt><span class="sect2"><a href="ch07s07.html#idp21058256">Building and Trying FileMQ</a></span></dt><dt><span class="sect2"><a href="ch07s07.html#idp21062232">Internal Architecture</a></span></dt><dt><span class="sect2"><a href="ch07s07.html#idp21074432">Public API</a></span></dt><dt><span class="sect2"><a href="ch07s07.html#idp21080776">Design Notes</a></span></dt><dt><span class="sect2"><a href="ch07s07.html#idp21087192">Configuration</a></span></dt><dt><span class="sect2"><a href="ch07s07.html#idp21094016">File Stability</a></span></dt><dt><span class="sect2"><a href="ch07s07.html#idp21095976">Delivery Notifications</a></span></dt><dt><span class="sect2"><a href="ch07s07.html#idp21097944">Symbolic Links</a></span></dt><dt><span class="sect2"><a href="ch07s07.html#idp21103200">Recovery and Late Joiners</a></span></dt><dt><span class="sect2"><a href="ch07s07.html#idp21115440">Test Use Case: The Track Tool</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch07s08.html">Getting an Official Port Number</a></span></dt></dl></div><p>One of the effects of using ØMQ at large scale is that because we can build distributed architectures so much faster than before, the limitations of our software engineering processes become more visible. Mistakes in slow motion are often harder to see (or rather, easier to rationalize away).</p><p>My experience when teaching ØMQ to groups of engineers is that it's rarely sufficient to just explain how ØMQ works and then just expect them to start building successful products. Like any technology that removes friction, ØMQ opens the door to big blunders. If ØMQ is the ACME rocket-propelled shoe of distributed software development, a lot of us are like Wile E. Coyote, slamming full speed into the proverbial desert cliff.</p><p>We saw in The ØMQ Community<a class="xref" href="ch06.html" title="Chapter 6. The ØMQ Community">Chapter 6, <em>The ØMQ Community</em></a> that ØMQ itself uses a formal process for changes. One reason we built this process, over some years, was to stop the repeated cliff-slamming that happened in the library itself.</p><p>Partly, it's about slowing down and partially, it's about ensuring that when you move fast, you go--and this is essential Dear Reader--in the <span class="emphasis"><em>right direction</em></span>. It's my standard interview riddle: what's the rarest property of any software system, the absolute hardest thing to get right, the lack of which causes the slow or fast death of the vast majority of projects? The answer is not code quality, funding, performance, or even (though it's a close answer), popularity. The answer is <span class="emphasis"><em>accuracy</em></span>.</p><p>Accuracy is half the challenge, and applies to any engineering work. The other half is distributed computing itself, which sets up a whole range of problems that we need to solve if we are going to create architectures. We need to encode and decode data; we need to define protocols to connect clients and servers; we need to secure these protocols against attackers; and we need to make stacks that are robust. Asynchronous messaging is hard to get right.</p><p>This chapter will tackle these challenges, starting with a basic reappraisal of how to design and build software and ending with a fully formed example of a distributed application for large-scale file distribution.</p><p>We'll cover the following juicy topics:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>How to go from idea to working prototype safely (the MOPED pattern)</p></li><li class="listitem"><p>Different ways to serialize your data as ØMQ messages</p></li><li class="listitem"><p>How to code-generate binary serialization codecs</p></li><li class="listitem"><p>How to build custom code generators using the GSL tool</p></li><li class="listitem"><p>How to write and license a protocol specification</p></li><li class="listitem"><p>How to build fast restartable file transfer over ØMQ</p></li><li class="listitem"><p>How to use credit-based flow control for nonblocking transfers</p></li><li class="listitem"><p>How to build protocol servers and clients as state machines</p></li><li class="listitem"><p>How to make a secure protocol over ØMQ</p></li><li class="listitem"><p>A large-scale file publishing system (FileMQ)</p></li></ul></div><div class="sect1" title="Message-Oriented Pattern for Elastic Design"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp20828872"></a>Message-Oriented Pattern for Elastic Design</h2></div></div></div><p>I'll introduce Message-Oriented Pattern for Elastic Design (MOPED), a software engineering pattern for ØMQ architectures. It was either "MOPED" or "BIKE", the Backronym-Induced Kinetic Effect. That's short for "BICICLE", the Backronym-Inflated See if I Care Less Effect. In life, one learns to go with the least embarrassing choice.</p><p>If you've read this book carefully, you'll have seen MOPED in action already. The development of Majordomo in Reliable Request-Reply Patterns<a class="xref" href="ch04.html" title="Chapter 4. Reliable Request-Reply Patterns">Chapter 4, <em>Reliable Request-Reply Patterns</em></a> is a near-perfect case. But cute names are worth a thousand words.</p><p>The goal of MOPED is to define a process by which we can take a rough use case for a new distributed application, and go from "Hello World" to fully-working prototype in any language in under a week.</p><p>Using MOPED, you grow, more than build, a working ØMQ architecture from the ground-up with minimal risk of failure. By focusing on the contracts rather than the implementations, you avoid the risk of premature optimization. By driving the design process through ultra-short test-based cycles, you can be more certain that what you have works before you add more.</p><p>We can turn this into five real steps:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Step 1: internalize the ØMQ semantics.</p></li><li class="listitem"><p>Step 2: draw a rough architecture.</p></li><li class="listitem"><p>Step 3: decide on the contracts.</p></li><li class="listitem"><p>Step 4: make a minimal end-to-end solution.</p></li><li class="listitem"><p>Step 5: solve one problem and repeat.</p></li></ul></div><div class="sect2" title="Step 1: Internalize the Semantics"><div class="titlepage"><div><div><h3 class="title"><a id="idp20833352"></a>Step 1: Internalize the Semantics</h3></div></div></div><p>You must learn and digest ØMQ's "language", that is, the socket patterns and how they work. The only way to learn a language is to use it. There's no way to avoid this investment, no tapes you can play while you sleep, no chips you can plug in to magically become smarter. Read this book from the start, work through the code examples in whatever language you prefer, understand what's going on, and (most importantly) write some examples yourself and then throw them away.</p><p>At a certain point, you'll feel a clicking noise in your brain. Maybe you'll have a weird chili-induced dream where little ØMQ tasks run around trying to eat you alive. Maybe you'll just think "aaahh, so <span class="emphasis"><em>that's</em></span> what it means!" If we did our work right, it should take two to three days. However long it takes, until you start thinking in terms of ØMQ sockets and patterns, you're not ready for step 2.</p></div><div class="sect2" title="Step 2: Draw a Rough Architecture"><div class="titlepage"><div><div><h3 class="title"><a id="idp20834984"></a>Step 2: Draw a Rough Architecture</h3></div></div></div><p>From my experience, it's essential to be able to draw the core of your architecture. It helps others understand what you are thinking, and it also helps you think through your ideas. There is really no better way to design a good architecture than to explain your ideas to your colleagues, using a whiteboard.</p><p>You don't need to get it right, and you don't need to make it complete. What you do need to do is break your architecture into pieces that make sense. The nice thing about software architecture (as compared to constructing bridges) is that your really can replace entire layers cheaply if you've isolated them.</p><p>Start by choosing the core problem that you are going to solve. Ignore anything that's not essential to that problem: you will add it in later. The problem should be an end-to-end problem: the rope across the gorge.</p><p>For example, a client asked us to make a supercomputing cluster with ØMQ. Clients create bundles of work, which are sent to a broker that distributes them to workers (running on fast graphics processors), collects the results back, and returns them to the client.</p><p>The rope across the gorge is one client talking to a broker talking to one worker. We draw three boxes: client, broker, worker. We draw arrows from box to box showing the request flowing one way and the response flowing back. It's just like the many diagrams we saw in earlier chapters.</p><p>Be minimalistic. Your goal is not to define a <span class="emphasis"><em>real</em></span> architecture, but to throw a rope across the gorge to bootstrap your process. We make the architecture successfully more complete and realistic over time: e.g., adding multiple workers, adding client and worker APIs, handling failures, and so on.</p></div><div class="sect2" title="Step 3: Decide on the Contracts"><div class="titlepage"><div><div><h3 class="title"><a id="idp20838736"></a>Step 3: Decide on the Contracts</h3></div></div></div><p>A good software architecture depends on contracts, and the more explicit they are, the better things scale. You don't care <span class="emphasis"><em>how</em></span> things happen; you only care about the results. If I send an email, I don't care how it arrives at its destination, as long as the contract is respected. The email contract is: it arrives within a few minutes, no-one modifies it, and it doesn't get lost.</p><p>And to build a large system that works well, you must focus on the contracts before the implementations. It may sound obvious but all too often, people forget or ignore this, or are just too shy to impose themselves. I wish I could say ØMQ had done this properly, but for years our public contracts were second-rate afterthoughts instead of primary in-your-face pieces of work.</p><p>So what is a contract in a distributed system? There are, in my experience, two types of contract:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The APIs to client applications. Remember the Psychological Elements. The APIs need to be as absolutely <span class="emphasis"><em>simple</em></span>, <span class="emphasis"><em>consistent</em></span>, and <span class="emphasis"><em>familiar</em></span> as possible. Yes, you can generate API documentation from code, but you must first design it, and designing an API is often hard.</p></li><li class="listitem"><p>The protocols that connect the pieces. It sounds like rocket science, but it's really just a simple trick, and one that ØMQ makes particularly easy. In fact they're so simple to write, and need so little bureaucracy that I call them <span class="emphasis"><em>unprotocols</em></span>.</p></li></ul></div><p>You write minimal contracts that are mostly just place markers. Most messages and most API methods will be missing or empty. You also want to write down any known technical requirements in terms of throughput, latency, reliability, and so on. These are the criteria on which you will accept or reject any particular piece of work.</p></div><div class="sect2" title="Step 4: Write a Minimal End-to-End Solution"><div class="titlepage"><div><div><h3 class="title"><a id="idp20843312"></a>Step 4: Write a Minimal End-to-End Solution</h3></div></div></div><p>The goal is to test out the overall architecture as rapidly as possible. Make skeleton applications that call the APIs, and skeleton stacks that implement both sides of every protocol. You want to get a working end-to-end "Hello World" as soon as you can. You want to be able to test code as you write it, so that you can weed out the broken assumptions and inevitable errors you make. Do not go off and spend six months writing a test suite! Instead, make a minimal bare-bones application that uses our still-hypothetical API.</p><p>If you design an API wearing the hat of the person who implements it, you'll start to think of performance, features, options, and so on. You'll make it more complex, more irregular, and more surprising than it should be. But, and here's the trick (it's a cheap one, was big in Japan): if you design an API while wearing the hat of the person who has to actually write apps that use it, you use all that laziness and fear to your advantage.</p><p>Write down the protocols on a wiki or shared document in such a way that you can explain every command clearly without too much detail. Strip off any real functionality, because it will only create inertia that makes it harder to move stuff around. You can always add weight. Don't spend effort defining formal message structures: pass the minimum around in the simplest possible fashion using ØMQ's multipart framing.</p><p>Our goal is to get the simplest test case working, without any avoidable functionality. Everything you can chop off the list of things to do, you chop. Ignore the groans from colleagues and bosses. I'll repeat this once again: you can <span class="emphasis"><em>always</em></span> add functionality, that's relatively easy. But aim to keep the overall weight to a minimum.</p></div><div class="sect2" title="Step 5: Solve One Problem and Repeat"><div class="titlepage"><div><div><h3 class="title"><a id="idp20846488"></a>Step 5: Solve One Problem and Repeat</h3></div></div></div><p>You're now in the happy cycle of issue-driven development where you can start to solve tangible problems instead of adding features. Write issues that each state a clear problem, and propose a solution. As you design the API, keep in mind your standards for names, consistency, and behavior. Writing these down in prose often helps keep them sane.</p><p>From here, every single change you make to the architecture and code can be proven by running the test case, watching it not work, making the change, and then watching it work.</p><p>Now you go through the whole cycle (extending the test case, fixing the API, updating the protocol, and extending the code, as needed), taking problems one at a time and testing the solutions individually. It should take about 10-30 minutes for each cycle, with the occasional spike due to random confusion.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch06s08.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch07s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Patterns for Success </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Unprotocols</td></tr></table></div></body></html>
