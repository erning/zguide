<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 4. Reliable Request-Reply Patterns</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="prev" href="ch03s07.html" title="Worked Example: Inter-Broker Routing" /><link rel="next" href="ch04s02.html" title="Designing Reliability" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 4. Reliable Request-Reply Patterns</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03s07.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch04s02.html">Next</a></td></tr></table><hr /></div><div class="chapter" title="Chapter 4. Reliable Request-Reply Patterns"><div class="titlepage"><div><div><h2 class="title"><a id="reliable-request-reply"></a>Chapter 4. Reliable Request-Reply Patterns</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="sect1"><a href="ch04.html#idp19679256">What is "Reliability"?</a></span></dt><dt><span class="sect1"><a href="ch04s02.html">Designing Reliability</a></span></dt><dt><span class="sect1"><a href="ch04s03.html">Client-Side Reliability (Lazy Pirate Pattern)</a></span></dt><dt><span class="sect1"><a href="ch04s04.html">Basic Reliable Queuing (Simple Pirate Pattern)</a></span></dt><dt><span class="sect1"><a href="ch04s05.html">Robust Reliable Queuing (Paranoid Pirate Pattern)</a></span></dt><dt><span class="sect1"><a href="ch04s06.html">Heartbeating</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch04s06.html#idp19764464">Shrugging It Off</a></span></dt><dt><span class="sect2"><a href="ch04s06.html#idp19766952">One-Way Heartbeats</a></span></dt><dt><span class="sect2"><a href="ch04s06.html#idp19770992">Ping-Pong Heartbeats</a></span></dt><dt><span class="sect2"><a href="ch04s06.html#idp19772480">Heartbeating for Paranoid Pirate</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch04s07.html">Contracts and Protocols</a></span></dt><dt><span class="sect1"><a href="ch04s08.html">Service-Oriented Reliable Queuing (Majordomo Pattern)</a></span></dt><dt><span class="sect1"><a href="ch04s09.html">Asynchronous Majordomo Pattern</a></span></dt><dt><span class="sect1"><a href="ch04s10.html">Service Discovery</a></span></dt><dt><span class="sect1"><a href="ch04s11.html">Idempotent Services</a></span></dt><dt><span class="sect1"><a href="ch04s12.html">Disconnected Reliability (Titanic Pattern)</a></span></dt><dt><span class="sect1"><a href="ch04s13.html">High-Availability Pair (Binary Star Pattern)</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch04s13.html#idp19997720">Detailed Requirements</a></span></dt><dt><span class="sect2"><a href="ch04s13.html#idp20017544">Preventing Split-Brain Syndrome</a></span></dt><dt><span class="sect2"><a href="ch04s13.html#idp20020800">Binary Star Implementation</a></span></dt><dt><span class="sect2"><a href="ch04s13.html#idp20045712">Binary Star Reactor</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch04s14.html">Brokerless Reliability (Freelance Pattern)</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch04s14.html#idp20080512">Model One: Simple Retry and Failover</a></span></dt><dt><span class="sect2"><a href="ch04s14.html#idp20092136">Model Two: Brutal Shotgun Massacre</a></span></dt><dt><span class="sect2"><a href="ch04s14.html#idp20115664">Model Three: Complex and Nasty</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch04s15.html">Conclusion</a></span></dt></dl></div><p>Advanced Request-Reply Patterns<a class="xref" href="ch03.html" title="Chapter 3. Advanced Request-Reply Patterns">Chapter 3, <em>Advanced Request-Reply Patterns</em></a> covered advanced uses of ØMQ's request-reply pattern with working examples. This chapter looks at the general question of reliability and builds a set of reliable messaging patterns on top of ØMQ's core request-reply pattern.</p><p>In this chapter, we focus heavily on user-space request-reply <span class="emphasis"><em>patterns</em></span>, reusable models that help you design your own ØMQ architectures:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The <span class="emphasis"><em>Lazy Pirate</em></span> pattern: reliable request-reply from the client side</p></li><li class="listitem"><p>The <span class="emphasis"><em>Simple Pirate</em></span> pattern: reliable request-reply using load balancing</p></li><li class="listitem"><p>The <span class="emphasis"><em>Paranoid Pirate</em></span> pattern: reliable request-reply with heartbeating</p></li><li class="listitem"><p>The <span class="emphasis"><em>Majordomo</em></span> pattern: service-oriented reliable queuing</p></li><li class="listitem"><p>The <span class="emphasis"><em>Titanic</em></span> pattern: disk-based/disconnected reliable queuing</p></li><li class="listitem"><p>The <span class="emphasis"><em>Binary Star</em></span> pattern: primary-backup server failover</p></li><li class="listitem"><p>The <span class="emphasis"><em>Freelance</em></span> pattern: brokerless reliable request-reply</p></li></ul></div><div class="sect1" title="What is &quot;Reliability&quot;?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp19679256"></a>What is "Reliability"?</h2></div></div></div><p>Most people who speak of "reliability" don't really know what they mean. We can only define reliability in terms of failure. That is, if we can handle a certain set of well-defined and understood failures, then we are reliable with respect to those failures. No more, no less. So let's look at the possible causes of failure in a distributed ØMQ application, in roughly descending order of probability:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Application code is the worst offender. It can crash and exit, freeze and stop responding to input, run too slowly for its input, exhaust all memory, and so on.</p></li><li class="listitem"><p>System code--such as brokers we write using ØMQ--can die for the same reasons as application code. System code <span class="emphasis"><em>should</em></span> be more reliable than application code, but it can still crash and burn, and especially run out of memory if it tries to queue messages for slow clients.</p></li><li class="listitem"><p>Message queues can overflow, typically in system code that has learned to deal brutally with slow clients. When a queue overflows, it starts to discard messages. So we get "lost" messages.</p></li><li class="listitem"><p>Networks can fail (e.g., WiFi gets switched off or goes out of range). ØMQ will automatically reconnect in such cases, but in the meantime, messages may get lost.</p></li><li class="listitem"><p>Hardware can fail and take with it all the processes running on that box.</p></li><li class="listitem"><p>Networks can fail in exotic ways, e.g., some ports on a switch may die and those parts of the network become inaccessible.</p></li><li class="listitem"><p>Entire data centers can be struck by lightning, earthquakes, fire, or more mundane power or cooling failures.</p></li></ul></div><p>To make a software system fully reliable against <span class="emphasis"><em>all</em></span> of these possible failures is an enormously difficult and expensive job and goes beyond the scope of this book.</p><p>Because the first five cases in the above list cover 99.9% of real world requirements outside large companies (according to a highly scientific study I just ran, which also told me that 78% of statistics are made up on the spot, and moreover never to trust a statistic that we didn't falsify ourselves), that's what we'll examine. If you're a large company with money to spend on the last two cases, contact my company immediately! There's a large hole behind my beach house waiting to be converted into an executive swimming pool.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03s07.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch04s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Worked Example: Inter-Broker Routing </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Designing Reliability</td></tr></table></div></body></html>
