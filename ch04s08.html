<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Service-Oriented Reliable Queuing (Majordomo Pattern)</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="ch04.html" title="Chapter 4. Reliable Request-Reply Patterns" /><link rel="prev" href="ch04s07.html" title="Contracts and Protocols" /><link rel="next" href="ch04s09.html" title="Asynchronous Majordomo Pattern" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Service-Oriented Reliable Queuing (Majordomo Pattern)</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04s07.html">Prev</a> </td><th width="60%" align="center">Chapter 4. Reliable Request-Reply Patterns</th><td width="20%" align="right"> <a accesskey="n" href="ch04s09.html">Next</a></td></tr></table><hr /></div><div class="sect1" title="Service-Oriented Reliable Queuing (Majordomo Pattern)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp19789512"></a>Service-Oriented Reliable Queuing (Majordomo Pattern)</h2></div></div></div><div class="figure"><a id="figure-50"></a><p class="title"><strong>Figure 4.4. The Majordomo Pattern</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/fig50.png" alt="The Majordomo Pattern" /></div></div></div><br class="figure-break" /><p>The nice thing about progress is how fast it happens when lawyers and committees aren't involved. The <a class="ulink" href="http://rfc.zeromq.org/spec:7" target="_top">one-page MDP specification</a> turns PPP into something more solid<a class="xref" href="ch04s12.html#figure-51" title="Figure 4.5. The Titanic Pattern">Figure 4.5, “The Titanic Pattern”</a>. This is how we should design complex architectures: start by writing down the contracts, and only <span class="emphasis"><em>then</em></span> write software to implement them.</p><p>The Majordomo Protocol (MDP) extends and improves on PPP in one interesting way: it adds a "service name" to requests that the client sends, and asks workers to register for specific services. Adding service names turns our Paranoid Pirate queue into a service-oriented broker. The nice thing about MDP is that it came out of working code, a simpler ancestor protocol (PPP), and a precise set of improvements that each solved a clear problem. This made it easy to draft.</p><p>To implement Majordomo, we need to write a framework for clients and workers. It's really not sane to ask every application developer to read the spec and make it work, when they could be using a simpler API that does the work for them.</p><p>So while our first contract (MDP itself) defines how the pieces of our distributed architecture talk to each other, our second contract defines how user applications talk to the technical framework we're going to design.</p><p>Majordomo has two halves, a client side and a worker side. Because we'll write both client and worker applications, we will need two APIs. Here is a sketch for the client API, using a simple object-oriented approach:</p><pre class="programlisting">
mdcli_t *mdcli_new     (char *broker);
void     mdcli_destroy (mdcli_t **self_p);
zmsg_t  *mdcli_send    (mdcli_t *self, char *service, zmsg_t **request_p);
</pre><p>That's it. We open a session to the broker, send a request message, get a reply message back, and eventually close the connection. Here's a sketch for the worker API:</p><pre class="programlisting">
mdwrk_t *mdwrk_new     (char *broker,char *service);
void     mdwrk_destroy (mdwrk_t **self_p);
zmsg_t  *mdwrk_recv    (mdwrk_t *self, zmsg_t *reply);
</pre><p>It's more or less symmetrical, but the worker dialog is a little different. The first time a worker does a recv(), it passes a null reply. Thereafter, it passes the current reply, and gets a new request.</p><p>The client and worker APIs were fairly simple to construct because they're heavily based on the Paranoid Pirate code we already developed. Here is the client API:</p><div class="example"><a id="mdcliapi-c"></a><p class="title"><strong>Example 4.18. Majordomo client API (mdcliapi.c)</strong></p><div class="example-contents"><pre class="programlisting">
//  mdcliapi class - Majordomo Protocol Client API
//  Implements the MDP/Worker spec at http://rfc.zeromq.org/spec:7.

#include "mdcliapi.h"

//  Structure of our class
//  We access these properties only via class methods

struct _mdcli_t {
    zctx_t *ctx;                //  Our context
    char *broker;
    void *client;               //  Socket to broker
    int verbose;                //  Print activity to stdout
    int timeout;                //  Request timeout
    int retries;                //  Request retries
};

//  Connect or reconnect to broker

void s_mdcli_connect_to_broker (mdcli_t *self)
{
    if (self-&gt;client)
        zsocket_destroy (self-&gt;ctx, self-&gt;client);
    self-&gt;client = zsocket_new (self-&gt;ctx, ZMQ_REQ);
    zmq_connect (self-&gt;client, self-&gt;broker);
    if (self-&gt;verbose)
        zclock_log ("I: connecting to broker at %s...", self-&gt;broker);
}
</pre></div></div><br class="example-break" /><p>Here we have the constructor and destructor for our class: 
</p><div class="example"><a id="mdcliapi-c-1"></a><p class="title"><strong>Example 4.19. Majordomo client API (mdcliapi.c) - constructor and destructor</strong></p><div class="example-contents"><pre class="programlisting">

//  Constructor

mdcli_t *
mdcli_new (char *broker, int verbose)
{
    assert (broker);

    mdcli_t *self = (mdcli_t *) zmalloc (sizeof (mdcli_t));
    self-&gt;ctx = zctx_new ();
    self-&gt;broker = strdup (broker);
    self-&gt;verbose = verbose;
    self-&gt;timeout = 2500;           //  msecs
    self-&gt;retries = 3;              //  Before we abandon

    s_mdcli_connect_to_broker (self);
    return self;
}

//  Destructor

void
mdcli_destroy (mdcli_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        mdcli_t *self = *self_p;
        zctx_destroy (&amp;self-&gt;ctx);
        free (self-&gt;broker);
        free (self);
        *self_p = NULL;
    }
}
</pre></div></div><br class="example-break" /><p>These are the class methods. We can set the request timeout and number of retry attempts before sending requests: 
</p><div class="example"><a id="mdcliapi-c-2"></a><p class="title"><strong>Example 4.20. Majordomo client API (mdcliapi.c) - configure retry behavior</strong></p><div class="example-contents"><pre class="programlisting">

//  Set request timeout

void
mdcli_set_timeout (mdcli_t *self, int timeout)
{
    assert (self);
    self-&gt;timeout = timeout;
}

//  Set request retries

void
mdcli_set_retries (mdcli_t *self, int retries)
{
    assert (self);
    self-&gt;retries = retries;
}
</pre></div></div><br class="example-break" /><p>Here is the <code class="literal">send</code> method. It sends a request to the broker and gets a reply even if it has to retry several times. It takes ownership of the request message, and destroys it when sent. It returns the reply message, or NULL if there was no reply after multiple attempts: 
</p><div class="example"><a id="mdcliapi-c-3"></a><p class="title"><strong>Example 4.21. Majordomo client API (mdcliapi.c) - send request and wait for reply</strong></p><div class="example-contents"><pre class="programlisting">

zmsg_t *
mdcli_send (mdcli_t *self, char *service, zmsg_t **request_p)
{
    assert (self);
    assert (request_p);
    zmsg_t *request = *request_p;

    //  Prefix request with protocol frames
    //  Frame 1: "MDPCxy" (six bytes, MDP/Client x.y)
    //  Frame 2: Service name (printable string)
    zmsg_pushstr (request, service);
    zmsg_pushstr (request, MDPC_CLIENT);
    if (self-&gt;verbose) {
        zclock_log ("I: send request to '%s' service:", service);
        zmsg_dump (request);
    }
    int retries_left = self-&gt;retries;
    while (retries_left &amp;&amp; !zctx_interrupted) {
        zmsg_t *msg = zmsg_dup (request);
        zmsg_send (&amp;msg, self-&gt;client);

        zmq_pollitem_t items [] = {
            { self-&gt;client, 0, ZMQ_POLLIN, 0 }
        };
</pre></div></div><br class="example-break" /><p>On any blocking call, <code class="literal">libzmq</code> will return -1 if there was an error; we could in theory check for different error codes, but in practice it's OK to assume it was <code class="literal">EINTR</code> (Ctrl-C): 
</p><div class="example"><a id="mdcliapi-c-4"></a><p class="title"><strong>Example 4.22. Majordomo client API (mdcliapi.c) - body of send </strong></p><div class="example-contents"><pre class="programlisting">
        int rc = zmq_poll (items, 1, self-&gt;timeout * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;          //  Interrupted

        //  If we got a reply, process it
        if (items [0].revents &amp; ZMQ_POLLIN) {
            zmsg_t *msg = zmsg_recv (self-&gt;client);
            if (self-&gt;verbose) {
                zclock_log ("I: received reply:");
                zmsg_dump (msg);
            }
            //  We would handle malformed replies better in real code
            assert (zmsg_size (msg) &gt;= 3);

            zframe_t *header = zmsg_pop (msg);
            assert (zframe_streq (header, MDPC_CLIENT));
            zframe_destroy (&amp;header);

            zframe_t *reply_service = zmsg_pop (msg);
            assert (zframe_streq (reply_service, service));
            zframe_destroy (&amp;reply_service);

            zmsg_destroy (&amp;request);
            return msg;     //  Success
        }
        else
        if (--retries_left) {
            if (self-&gt;verbose)
                zclock_log ("W: no reply, reconnecting...");
            s_mdcli_connect_to_broker (self);
        }
        else {
            if (self-&gt;verbose)
                zclock_log ("W: permanent error, abandoning");
            break;          //  Give up
        }
    }
    if (zctx_interrupted)
        printf ("W: interrupt received, killing client...\n");
    zmsg_destroy (&amp;request);
    return NULL;
}
</pre></div></div><br class="example-break" /><p>Let's see how the client API looks in action, with an example test program that does 100K request-reply cycles:</p><div class="example"><a id="mdclient-c"></a><p class="title"><strong>Example 4.23. Majordomo client application (mdclient.c)</strong></p><div class="example-contents"><pre class="programlisting">
//  Majordomo Protocol client example
//  Uses the mdcli API to hide all MDP aspects

//  Lets us build this source without creating a library
#include "mdcliapi.c"

int main (int argc, char *argv [])
{
    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], "-v"));
    mdcli_t *session = mdcli_new ("tcp://localhost:5555", verbose);

    int count;
    for (count = 0; count &lt; 100000; count++) {
        zmsg_t *request = zmsg_new ();
        zmsg_pushstr (request, "Hello world");
        zmsg_t *reply = mdcli_send (session, "echo", &amp;request);
        if (reply)
            zmsg_destroy (&amp;reply);
        else
            break;              //  Interrupt or failure
    }
    printf ("%d requests/replies processed\n", count);
    mdcli_destroy (&amp;session);
    return 0;
}
</pre></div></div><br class="example-break" /><p>And here is the worker API:</p><div class="example"><a id="mdwrkapi-c"></a><p class="title"><strong>Example 4.24. Majordomo worker API (mdwrkapi.c)</strong></p><div class="example-contents"><pre class="programlisting">
//  mdwrkapi class - Majordomo Protocol Worker API
//  Implements the MDP/Worker spec at http://rfc.zeromq.org/spec:7.

#include "mdwrkapi.h"

//  Reliability parameters
#define HEARTBEAT_LIVENESS  3       //  3-5 is reasonable
</pre></div></div><br class="example-break" /><p>This is the structure of a worker API instance. We use a pseudo-OO approach in a lot of the C examples, as well as the CZMQ binding: 
</p><div class="example"><a id="mdwrkapi-c-1"></a><p class="title"><strong>Example 4.25. Majordomo worker API (mdwrkapi.c) - worker class structure</strong></p><div class="example-contents"><pre class="programlisting">

//  Structure of our class
//  We access these properties only via class methods

struct _mdwrk_t {
    zctx_t *ctx;                //  Our context
    char *broker;
    char *service;
    void *worker;               //  Socket to broker
    int verbose;                //  Print activity to stdout

    //  Heartbeat management
    uint64_t heartbeat_at;      //  When to send HEARTBEAT
    size_t liveness;            //  How many attempts left
    int heartbeat;              //  Heartbeat delay, msecs
    int reconnect;              //  Reconnect delay, msecs

    int expect_reply;           //  Zero only at start
    zframe_t *reply_to;         //  Return identity, if any
};
</pre></div></div><br class="example-break" /><p>We have two utility functions; to send a message to the broker and to (re)connect to the broker: 
</p><div class="example"><a id="mdwrkapi-c-2"></a><p class="title"><strong>Example 4.26. Majordomo worker API (mdwrkapi.c) - utility functions</strong></p><div class="example-contents"><pre class="programlisting">

//  Send message to broker
//  If no msg is provided, creates one internally

static void
s_mdwrk_send_to_broker (mdwrk_t *self, char *command, char *option,
                        zmsg_t *msg)
{
    msg = msg? zmsg_dup (msg): zmsg_new ();

    //  Stack protocol envelope to start of message
    if (option)
        zmsg_pushstr (msg, option);
    zmsg_pushstr (msg, command);
    zmsg_pushstr (msg, MDPW_WORKER);
    zmsg_pushstr (msg, "");

    if (self-&gt;verbose) {
        zclock_log ("I: sending %s to broker",
            mdps_commands [(int) *command]);
        zmsg_dump (msg);
    }
    zmsg_send (&amp;msg, self-&gt;worker);
}

//  Connect or reconnect to broker

void s_mdwrk_connect_to_broker (mdwrk_t *self)
{
    if (self-&gt;worker)
        zsocket_destroy (self-&gt;ctx, self-&gt;worker);
    self-&gt;worker = zsocket_new (self-&gt;ctx, ZMQ_DEALER);
    zmq_connect (self-&gt;worker, self-&gt;broker);
    if (self-&gt;verbose)
        zclock_log ("I: connecting to broker at %s...", self-&gt;broker);

    //  Register service with broker
    s_mdwrk_send_to_broker (self, MDPW_READY, self-&gt;service, NULL);

    //  If liveness hits zero, queue is considered disconnected
    self-&gt;liveness = HEARTBEAT_LIVENESS;
    self-&gt;heartbeat_at = zclock_time () + self-&gt;heartbeat;
}
</pre></div></div><br class="example-break" /><p>Here we have the constructor and destructor for our mdwrk class: 
</p><div class="example"><a id="mdwrkapi-c-3"></a><p class="title"><strong>Example 4.27. Majordomo worker API (mdwrkapi.c) - constructor and destructor</strong></p><div class="example-contents"><pre class="programlisting">

//  Constructor

mdwrk_t *
mdwrk_new (char *broker,char *service, int verbose)
{
    assert (broker);
    assert (service);

    mdwrk_t *self = (mdwrk_t *) zmalloc (sizeof (mdwrk_t));
    self-&gt;ctx = zctx_new ();
    self-&gt;broker = strdup (broker);
    self-&gt;service = strdup (service);
    self-&gt;verbose = verbose;
    self-&gt;heartbeat = 2500;     //  msecs
    self-&gt;reconnect = 2500;     //  msecs

    s_mdwrk_connect_to_broker (self);
    return self;
}

//  Destructor

void
mdwrk_destroy (mdwrk_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        mdwrk_t *self = *self_p;
        zctx_destroy (&amp;self-&gt;ctx);
        free (self-&gt;broker);
        free (self-&gt;service);
        free (self);
        *self_p = NULL;
    }
}
</pre></div></div><br class="example-break" /><p>We provide two methods to configure the worker API. You can set the heartbeat interval and retries to match the expected network performance. 
</p><div class="example"><a id="mdwrkapi-c-4"></a><p class="title"><strong>Example 4.28. Majordomo worker API (mdwrkapi.c) - configure worker</strong></p><div class="example-contents"><pre class="programlisting">

//  Set heartbeat delay

void
mdwrk_set_heartbeat (mdwrk_t *self, int heartbeat)
{
    self-&gt;heartbeat = heartbeat;
}

//  Set reconnect delay

void
mdwrk_set_reconnect (mdwrk_t *self, int reconnect)
{
    self-&gt;reconnect = reconnect;
}
</pre></div></div><br class="example-break" /><p>This is the <code class="literal">recv</code> method; it's a little misnamed because it first sends any reply and then waits for a new request. If you have a better name for this, let me know. 
</p><div class="example"><a id="mdwrkapi-c-5"></a><p class="title"><strong>Example 4.29. Majordomo worker API (mdwrkapi.c) - recv method</strong></p><div class="example-contents"><pre class="programlisting">

//  Send reply, if any, to broker and wait for next request.

zmsg_t *
mdwrk_recv (mdwrk_t *self, zmsg_t **reply_p)
{
    //  Format and send the reply if we were provided one
    assert (reply_p);
    zmsg_t *reply = *reply_p;
    assert (reply || !self-&gt;expect_reply);
    if (reply) {
        assert (self-&gt;reply_to);
        zmsg_wrap (reply, self-&gt;reply_to);
        s_mdwrk_send_to_broker (self, MDPW_REPLY, NULL, reply);
        zmsg_destroy (reply_p);
    }
    self-&gt;expect_reply = 1;

    while (true) {
        zmq_pollitem_t items [] = {
            { self-&gt;worker,  0, ZMQ_POLLIN, 0 } };
        int rc = zmq_poll (items, 1, self-&gt;heartbeat * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  Interrupted

        if (items [0].revents &amp; ZMQ_POLLIN) {
            zmsg_t *msg = zmsg_recv (self-&gt;worker);
            if (!msg)
                break;          //  Interrupted
            if (self-&gt;verbose) {
                zclock_log ("I: received message from broker:");
                zmsg_dump (msg);
            }
            self-&gt;liveness = HEARTBEAT_LIVENESS;

            //  Don't try to handle errors, just assert noisily
            assert (zmsg_size (msg) &gt;= 3);

            zframe_t *empty = zmsg_pop (msg);
            assert (zframe_streq (empty, ""));
            zframe_destroy (&amp;empty);

            zframe_t *header = zmsg_pop (msg);
            assert (zframe_streq (header, MDPW_WORKER));
            zframe_destroy (&amp;header);

            zframe_t *command = zmsg_pop (msg);
            if (zframe_streq (command, MDPW_REQUEST)) {
                //  We should pop and save as many addresses as there are
                //  up to a null part, but for now, just save one...
                self-&gt;reply_to = zmsg_unwrap (msg);
                zframe_destroy (&amp;command);
</pre></div></div><br class="example-break" /><p>Here is where we actually have a message to process; we return it to the caller application: 
</p><div class="example"><a id="mdwrkapi-c-6"></a><p class="title"><strong>Example 4.30. Majordomo worker API (mdwrkapi.c) - process message</strong></p><div class="example-contents"><pre class="programlisting">
                return msg;     //  We have a request to process
            }
            else
            if (zframe_streq (command, MDPW_HEARTBEAT))
                ;               //  Do nothing for heartbeats
            else
            if (zframe_streq (command, MDPW_DISCONNECT))
                s_mdwrk_connect_to_broker (self);
            else {
                zclock_log ("E: invalid input message");
                zmsg_dump (msg);
            }
            zframe_destroy (&amp;command);
            zmsg_destroy (&amp;msg);
        }
        else
        if (--self-&gt;liveness == 0) {
            if (self-&gt;verbose)
                zclock_log ("W: disconnected from broker - retrying...");
            zclock_sleep (self-&gt;reconnect);
            s_mdwrk_connect_to_broker (self);
        }
        //  Send HEARTBEAT if it's time
        if (zclock_time () &gt; self-&gt;heartbeat_at) {
            s_mdwrk_send_to_broker (self, MDPW_HEARTBEAT, NULL, NULL);
            self-&gt;heartbeat_at = zclock_time () + self-&gt;heartbeat;
        }
    }
    if (zctx_interrupted)
        printf ("W: interrupt received, killing worker...\n");
    return NULL;
}
</pre></div></div><br class="example-break" /><p>Let's see how the worker API looks in action, with an example test program that implements an echo service:</p><div class="example"><a id="mdworker-c"></a><p class="title"><strong>Example 4.31. Majordomo worker application (mdworker.c)</strong></p><div class="example-contents"><pre class="programlisting">
//  Majordomo Protocol worker example
//  Uses the mdwrk API to hide all MDP aspects

//  Lets us build this source without creating a library
#include "mdwrkapi.c"

int main (int argc, char *argv [])
{
    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], "-v"));
    mdwrk_t *session = mdwrk_new (
        "tcp://localhost:5555", "echo", verbose);

    zmsg_t *reply = NULL;
    while (true) {
        zmsg_t *request = mdwrk_recv (session, &amp;reply);
        if (request == NULL)
            break;              //  Worker was interrupted
        reply = request;        //  Echo is complex... :-)
    }
    mdwrk_destroy (&amp;session);
    return 0;
}
</pre></div></div><br class="example-break" /><p>Here are some things to note about the worker API code:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The APIs are single-threaded. This means, for example, that the worker won't send heartbeats in the background. Happily, this is exactly what we want: if the worker application gets stuck, heartbeats will stop and the broker will stop sending requests to the worker.</p></li><li class="listitem"><p>The worker API doesn't do an exponential back-off; it's not worth the extra complexity.</p></li><li class="listitem"><p>The APIs don't do any error reporting. If something isn't as expected, they raise an assertion (or exception depending on the language). This is ideal for a reference implementation, so any protocol errors show immediately. For real applications, the API should be robust against invalid messages.</p></li></ul></div><p>You might wonder why the worker API is manually closing its socket and opening a new one, when ØMQ will automatically reconnect a socket if the peer disappears and comes back. Look back at the Simple Pirate and Paranoid Pirate workers to understand. Although ØMQ will automatically reconnect workers if the broker dies and comes back up, this isn't sufficient to re-register the workers with the broker. I know of at least two solutions. The simplest, which we use here, is for the worker to monitor the connection using heartbeats, and if it decides the broker is dead, to close its socket and start afresh with a new socket. The alternative is for the broker to challenge unknown workers when it gets a heartbeat from the worker and ask them to re-register. That would require protocol support.</p><p>Now let's design the Majordomo broker. Its core structure is a set of queues, one per service. We will create these queues as workers appear (we could delete them as workers disappear, but forget that for now because it gets complex). Additionally, we keep a queue of workers per service.</p><p>And here is the broker:</p><div class="example"><a id="mdbroker-c"></a><p class="title"><strong>Example 4.32. Majordomo broker (mdbroker.c)</strong></p><div class="example-contents"><pre class="programlisting">
//  Majordomo Protocol broker
//  A minimal C implementation of the Majordomo Protocol as defined in
//  http://rfc.zeromq.org/spec:7 and http://rfc.zeromq.org/spec:8.

#include "czmq.h"
#include "mdp.h"

//  We'd normally pull these from config data

#define HEARTBEAT_LIVENESS  3       //  3-5 is reasonable
#define HEARTBEAT_INTERVAL  2500    //  msecs
#define HEARTBEAT_EXPIRY    HEARTBEAT_INTERVAL * HEARTBEAT_LIVENESS
</pre></div></div><br class="example-break" /><p>The broker class defines a single broker instance: 
</p><div class="example"><a id="mdbroker-c-1"></a><p class="title"><strong>Example 4.33. Majordomo broker (mdbroker.c) - broker class structure</strong></p><div class="example-contents"><pre class="programlisting">

typedef struct {
    zctx_t *ctx;                //  Our context
    void *socket;               //  Socket for clients &amp; workers
    int verbose;                //  Print activity to stdout
    char *endpoint;             //  Broker binds to this endpoint
    zhash_t *services;          //  Hash of known services
    zhash_t *workers;           //  Hash of known workers
    zlist_t *waiting;           //  List of waiting workers
    uint64_t heartbeat_at;      //  When to send HEARTBEAT
} broker_t;

static broker_t *
    s_broker_new (int verbose);
static void
    s_broker_destroy (broker_t **self_p);
static void
    s_broker_bind (broker_t *self, char *endpoint);
static void
    s_broker_worker_msg (broker_t *self, zframe_t *sender, zmsg_t *msg);
static void
    s_broker_client_msg (broker_t *self, zframe_t *sender, zmsg_t *msg);
static void
    s_broker_purge (broker_t *self);
</pre></div></div><br class="example-break" /><p>The service class defines a single service instance: 
</p><div class="example"><a id="mdbroker-c-2"></a><p class="title"><strong>Example 4.34. Majordomo broker (mdbroker.c) - service class structure</strong></p><div class="example-contents"><pre class="programlisting">

typedef struct {
    broker_t *broker;           //  Broker instance
    char *name;                 //  Service name
    zlist_t *requests;          //  List of client requests
    zlist_t *waiting;           //  List of waiting workers
    size_t workers;             //  How many workers we have
} service_t;

static service_t *
    s_service_require (broker_t *self, zframe_t *service_frame);
static void
    s_service_destroy (void *argument);
static void
    s_service_dispatch (service_t *service, zmsg_t *msg);
</pre></div></div><br class="example-break" /><p>The worker class defines a single worker, idle or active: 
</p><div class="example"><a id="mdbroker-c-3"></a><p class="title"><strong>Example 4.35. Majordomo broker (mdbroker.c) - worker class structure</strong></p><div class="example-contents"><pre class="programlisting">

typedef struct {
    broker_t *broker;           //  Broker instance
    char *id_string;            //  Identity of worker as string
    zframe_t *identity;         //  Identity frame for routing
    service_t *service;         //  Owning service, if known
    int64_t expiry;             //  When worker expires, if no heartbeat
} worker_t;

static worker_t *
    s_worker_require (broker_t *self, zframe_t *identity);
static void
    s_worker_delete (worker_t *self, int disconnect);
static void
    s_worker_destroy (void *argument);
static void
    s_worker_send (worker_t *self, char *command, char *option,
                   zmsg_t *msg);
static void
    s_worker_waiting (worker_t *self);
</pre></div></div><br class="example-break" /><p>Here are the constructor and destructor for the broker: 
</p><div class="example"><a id="mdbroker-c-4"></a><p class="title"><strong>Example 4.36. Majordomo broker (mdbroker.c) - broker constructor and destructor</strong></p><div class="example-contents"><pre class="programlisting">

static broker_t *
s_broker_new (int verbose)
{
    broker_t *self = (broker_t *) zmalloc (sizeof (broker_t));

    //  Initialize broker state
    self-&gt;ctx = zctx_new ();
    self-&gt;socket = zsocket_new (self-&gt;ctx, ZMQ_ROUTER);
    self-&gt;verbose = verbose;
    self-&gt;services = zhash_new ();
    self-&gt;workers = zhash_new ();
    self-&gt;waiting = zlist_new ();
    self-&gt;heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;
    return self;
}

static void
s_broker_destroy (broker_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        broker_t *self = *self_p;
        zctx_destroy (&amp;self-&gt;ctx);
        zhash_destroy (&amp;self-&gt;services);
        zhash_destroy (&amp;self-&gt;workers);
        zlist_destroy (&amp;self-&gt;waiting);
        free (self);
        *self_p = NULL;
    }
}
</pre></div></div><br class="example-break" /><p>This method binds the broker instance to an endpoint. We can call this multiple times. Note that MDP uses a single socket for both clients and workers: 
</p><div class="example"><a id="mdbroker-c-5"></a><p class="title"><strong>Example 4.37. Majordomo broker (mdbroker.c) - broker bind method</strong></p><div class="example-contents"><pre class="programlisting">

void
s_broker_bind (broker_t *self, char *endpoint)
{
    zsocket_bind (self-&gt;socket, endpoint);
    zclock_log ("I: MDP broker/0.2.0 is active at %s", endpoint);
}
</pre></div></div><br class="example-break" /><p>This method processes one READY, REPLY, HEARTBEAT, or DISCONNECT message sent to the broker by a worker: 
</p><div class="example"><a id="mdbroker-c-6"></a><p class="title"><strong>Example 4.38. Majordomo broker (mdbroker.c) - broker worker_msg method</strong></p><div class="example-contents"><pre class="programlisting">

static void
s_broker_worker_msg (broker_t *self, zframe_t *sender, zmsg_t *msg)
{
    assert (zmsg_size (msg) &gt;= 1);     //  At least, command

    zframe_t *command = zmsg_pop (msg);
    char *id_string = zframe_strhex (sender);
    int worker_ready = (zhash_lookup (self-&gt;workers, id_string) != NULL);
    free (id_string);
    worker_t *worker = s_worker_require (self, sender);

    if (zframe_streq (command, MDPW_READY)) {
        if (worker_ready)               //  Not first command in session
            s_worker_delete (worker, 1);
        else
        if (zframe_size (sender) &gt;= 4  //  Reserved service name
        &amp;&amp;  memcmp (zframe_data (sender), "mmi.", 4) == 0)
            s_worker_delete (worker, 1);
        else {
            //  Attach worker to service and mark as idle
            zframe_t *service_frame = zmsg_pop (msg);
            worker-&gt;service = s_service_require (self, service_frame);
            worker-&gt;service-&gt;workers++;
            s_worker_waiting (worker);
            zframe_destroy (&amp;service_frame);
        }
    }
    else
    if (zframe_streq (command, MDPW_REPLY)) {
        if (worker_ready) {
            //  Remove and save client return envelope and insert the
            //  protocol header and service name, then rewrap envelope.
            zframe_t *client = zmsg_unwrap (msg);
            zmsg_pushstr (msg, worker-&gt;service-&gt;name);
            zmsg_pushstr (msg, MDPC_CLIENT);
            zmsg_wrap (msg, client);
            zmsg_send (&amp;msg, self-&gt;socket);
            s_worker_waiting (worker);
        }
        else
            s_worker_delete (worker, 1);
    }
    else
    if (zframe_streq (command, MDPW_HEARTBEAT)) {
        if (worker_ready)
            worker-&gt;expiry = zclock_time () + HEARTBEAT_EXPIRY;
        else
            s_worker_delete (worker, 1);
    }
    else
    if (zframe_streq (command, MDPW_DISCONNECT))
        s_worker_delete (worker, 0);
    else {
        zclock_log ("E: invalid input message");
        zmsg_dump (msg);
    }
    free (command);
    zmsg_destroy (&amp;msg);
}
</pre></div></div><br class="example-break" /><p>Process a request coming from a client. We implement MMI requests directly here (at present, we implement only the mmi.service request): 
</p><div class="example"><a id="mdbroker-c-7"></a><p class="title"><strong>Example 4.39. Majordomo broker (mdbroker.c) - broker client_msg method</strong></p><div class="example-contents"><pre class="programlisting">

static void
s_broker_client_msg (broker_t *self, zframe_t *sender, zmsg_t *msg)
{
    assert (zmsg_size (msg) &gt;= 2);     //  Service name + body

    zframe_t *service_frame = zmsg_pop (msg);
    service_t *service = s_service_require (self, service_frame);

    //  Set reply return identity to client sender
    zmsg_wrap (msg, zframe_dup (sender));

    //  If we got a MMI service request, process that internally
    if (zframe_size (service_frame) &gt;= 4
    &amp;&amp;  memcmp (zframe_data (service_frame), "mmi.", 4) == 0) {
        char *return_code;
        if (zframe_streq (service_frame, "mmi.service")) {
            char *name = zframe_strdup (zmsg_last (msg));
            service_t *service =
                (service_t *) zhash_lookup (self-&gt;services, name);
            return_code = service &amp;&amp; service-&gt;workers? "200": "404";
            free (name);
        }
        else
            return_code = "501";

        zframe_reset (zmsg_last (msg), return_code, strlen (return_code));

        //  Remove &amp; save client return envelope and insert the
        //  protocol header and service name, then rewrap envelope.
        zframe_t *client = zmsg_unwrap (msg);
        zmsg_push (msg, zframe_dup (service_frame));
        zmsg_pushstr (msg, MDPC_CLIENT);
        zmsg_wrap (msg, client);
        zmsg_send (&amp;msg, self-&gt;socket);
    }
    else
        //  Else dispatch the message to the requested service
        s_service_dispatch (service, msg);
    zframe_destroy (&amp;service_frame);
}
</pre></div></div><br class="example-break" /><p>This method deletes any idle workers that haven't pinged us in a while. We hold workers from oldest to most recent so we can stop scanning whenever we find a live worker. This means we'll mainly stop at the first worker, which is essential when we have large numbers of workers (we call this method in our critical path): 
</p><div class="example"><a id="mdbroker-c-8"></a><p class="title"><strong>Example 4.40. Majordomo broker (mdbroker.c) - broker purge method</strong></p><div class="example-contents"><pre class="programlisting">

static void
s_broker_purge (broker_t *self)
{
    worker_t *worker = (worker_t *) zlist_first (self-&gt;waiting);
    while (worker) {
        if (zclock_time () &lt; worker-&gt;expiry)
            break;                  //  Worker is alive, we're done here
        if (self-&gt;verbose)
            zclock_log ("I: deleting expired worker: %s",
                        worker-&gt;id_string);

        s_worker_delete (worker, 0);
        worker = (worker_t *) zlist_first (self-&gt;waiting);
    }
}
</pre></div></div><br class="example-break" /><p>Here is the implementation of the methods that work on a service: 
</p><div class="example"><a id="mdbroker-c-9"></a><p class="title"><strong>Example 4.41. Majordomo broker (mdbroker.c) - service methods</strong></p><div class="example-contents"><pre class="programlisting">

//  Lazy constructor that locates a service by name or creates a new
//  service if there is no service already with that name.

static service_t *
s_service_require (broker_t *self, zframe_t *service_frame)
{
    assert (service_frame);
    char *name = zframe_strdup (service_frame);

    service_t *service =
        (service_t *) zhash_lookup (self-&gt;services, name);
    if (service == NULL) {
        service = (service_t *) zmalloc (sizeof (service_t));
        service-&gt;broker = self;
        service-&gt;name = name;
        service-&gt;requests = zlist_new ();
        service-&gt;waiting = zlist_new ();
        zhash_insert (self-&gt;services, name, service);
        zhash_freefn (self-&gt;services, name, s_service_destroy);
        if (self-&gt;verbose)
            zclock_log ("I: added service: %s", name);
    }
    else
        free (name);

    return service;
}

//  Service destructor is called automatically whenever the service is
//  removed from broker-&gt;services.

static void
s_service_destroy (void *argument)
{
    service_t *service = (service_t *) argument;
    while (zlist_size (service-&gt;requests)) {
        zmsg_t *msg = zlist_pop (service-&gt;requests);
        zmsg_destroy (&amp;msg);
    }
    zlist_destroy (&amp;service-&gt;requests);
    zlist_destroy (&amp;service-&gt;waiting);
    free (service-&gt;name);
    free (service);
}
</pre></div></div><br class="example-break" /><p>This method sends requests to waiting workers: 
</p><div class="example"><a id="mdbroker-c-10"></a><p class="title"><strong>Example 4.42. Majordomo broker (mdbroker.c) - service dispatch method</strong></p><div class="example-contents"><pre class="programlisting">

static void
s_service_dispatch (service_t *self, zmsg_t *msg)
{
    assert (self);
    if (msg)                    //  Queue message if any
        zlist_append (self-&gt;requests, msg);

    s_broker_purge (self-&gt;broker);
    while (zlist_size (self-&gt;waiting) &amp;&amp; zlist_size (self-&gt;requests)) {
        worker_t *worker = zlist_pop (self-&gt;waiting);
        zlist_remove (self-&gt;broker-&gt;waiting, worker);
        zmsg_t *msg = zlist_pop (self-&gt;requests);
        s_worker_send (worker, MDPW_REQUEST, NULL, msg);
        zmsg_destroy (&amp;msg);
    }
}
</pre></div></div><br class="example-break" /><p>Here is the implementation of the methods that work on a worker: 
</p><div class="example"><a id="mdbroker-c-11"></a><p class="title"><strong>Example 4.43. Majordomo broker (mdbroker.c) - worker methods</strong></p><div class="example-contents"><pre class="programlisting">

//  Lazy constructor that locates a worker by identity, or creates a new
//  worker if there is no worker already with that identity.

static worker_t *
s_worker_require (broker_t *self, zframe_t *identity)
{
    assert (identity);

    //  self-&gt;workers is keyed off worker identity
    char *id_string = zframe_strhex (identity);
    worker_t *worker =
        (worker_t *) zhash_lookup (self-&gt;workers, id_string);

    if (worker == NULL) {
        worker = (worker_t *) zmalloc (sizeof (worker_t));
        worker-&gt;broker = self;
        worker-&gt;id_string = id_string;
        worker-&gt;identity = zframe_dup (identity);
        zhash_insert (self-&gt;workers, id_string, worker);
        zhash_freefn (self-&gt;workers, id_string, s_worker_destroy);
        if (self-&gt;verbose)
            zclock_log ("I: registering new worker: %s", id_string);
    }
    else
        free (id_string);
    return worker;
}

//  This method deletes the current worker.

static void
s_worker_delete (worker_t *self, int disconnect)
{
    assert (self);
    if (disconnect)
        s_worker_send (self, MDPW_DISCONNECT, NULL, NULL);

    if (self-&gt;service) {
        zlist_remove (self-&gt;service-&gt;waiting, self);
        self-&gt;service-&gt;workers--;
    }
    zlist_remove (self-&gt;broker-&gt;waiting, self);
    //  This implicitly calls s_worker_destroy
    zhash_delete (self-&gt;broker-&gt;workers, self-&gt;id_string);
}

//  Worker destructor is called automatically whenever the worker is
//  removed from broker-&gt;workers.

static void
s_worker_destroy (void *argument)
{
    worker_t *self = (worker_t *) argument;
    zframe_destroy (&amp;self-&gt;identity);
    free (self-&gt;id_string);
    free (self);
}
</pre></div></div><br class="example-break" /><p>This method formats and sends a command to a worker. The caller may also provide a command option, and a message payload: 
</p><div class="example"><a id="mdbroker-c-12"></a><p class="title"><strong>Example 4.44. Majordomo broker (mdbroker.c) - worker send method</strong></p><div class="example-contents"><pre class="programlisting">

static void
s_worker_send (worker_t *self, char *command, char *option, zmsg_t *msg)
{
    msg = msg? zmsg_dup (msg): zmsg_new ();

    //  Stack protocol envelope to start of message
    if (option)
        zmsg_pushstr (msg, option);
    zmsg_pushstr (msg, command);
    zmsg_pushstr (msg, MDPW_WORKER);

    //  Stack routing envelope to start of message
    zmsg_wrap (msg, zframe_dup (self-&gt;identity));

    if (self-&gt;broker-&gt;verbose) {
        zclock_log ("I: sending %s to worker",
            mdps_commands [(int) *command]);
        zmsg_dump (msg);
    }
    zmsg_send (&amp;msg, self-&gt;broker-&gt;socket);
}

//  This worker is now waiting for work

static void
s_worker_waiting (worker_t *self)
{
    //  Queue to broker and service waiting lists
    assert (self-&gt;broker);
    zlist_append (self-&gt;broker-&gt;waiting, self);
    zlist_append (self-&gt;service-&gt;waiting, self);
    self-&gt;expiry = zclock_time () + HEARTBEAT_EXPIRY;
    s_service_dispatch (self-&gt;service, NULL);
}
</pre></div></div><br class="example-break" /><p>Finally, here is the main task. We create a new broker instance and then process messages on the broker socket: 
</p><div class="example"><a id="mdbroker-c-13"></a><p class="title"><strong>Example 4.45. Majordomo broker (mdbroker.c) - main task</strong></p><div class="example-contents"><pre class="programlisting">

int main (int argc, char *argv [])
{
    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], "-v"));

    broker_t *self = s_broker_new (verbose);
    s_broker_bind (self, "tcp://*:5555");

    //  Get and process messages forever or until interrupted
    while (true) {
        zmq_pollitem_t items [] = {
            { self-&gt;socket,  0, ZMQ_POLLIN, 0 } };
        int rc = zmq_poll (items, 1, HEARTBEAT_INTERVAL * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  Interrupted

        //  Process next input message, if any
        if (items [0].revents &amp; ZMQ_POLLIN) {
            zmsg_t *msg = zmsg_recv (self-&gt;socket);
            if (!msg)
                break;          //  Interrupted
            if (self-&gt;verbose) {
                zclock_log ("I: received message:");
                zmsg_dump (msg);
            }
            zframe_t *sender = zmsg_pop (msg);
            zframe_t *empty  = zmsg_pop (msg);
            zframe_t *header = zmsg_pop (msg);

            if (zframe_streq (header, MDPC_CLIENT))
                s_broker_client_msg (self, sender, msg);
            else
            if (zframe_streq (header, MDPW_WORKER))
                s_broker_worker_msg (self, sender, msg);
            else {
                zclock_log ("E: invalid message:");
                zmsg_dump (msg);
                zmsg_destroy (&amp;msg);
            }
            zframe_destroy (&amp;sender);
            zframe_destroy (&amp;empty);
            zframe_destroy (&amp;header);
        }
        //  Disconnect and delete any expired workers
        //  Send heartbeats to idle workers if needed
        if (zclock_time () &gt; self-&gt;heartbeat_at) {
            s_broker_purge (self);
            worker_t *worker = (worker_t *) zlist_first (self-&gt;waiting);
            while (worker) {
                s_worker_send (worker, MDPW_HEARTBEAT, NULL, NULL);
                worker = (worker_t *) zlist_next (self-&gt;waiting);
            }
            self-&gt;heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;
        }
    }
    if (zctx_interrupted)
        printf ("W: interrupt received, shutting down...\n");

    s_broker_destroy (&amp;self);
    return 0;
}
</pre></div></div><br class="example-break" /><p>This is by far the most complex example we've seen. It's almost 500 lines of code. To write this and make it somewhat robust took two days. However, this is still a short piece of code for a full service-oriented broker.</p><p>Here are some things to note about the broker code:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The Majordomo Protocol lets us handle both clients and workers on a single socket. This is nicer for those deploying and managing the broker: it just sits on one ØMQ endpoint rather than the two that most proxies need.</p></li><li class="listitem"><p>The broker implements all of MDP/0.1 properly (as far as I know), including disconnection if the broker sends invalid commands, heartbeating, and the rest.</p></li><li class="listitem"><p>It can be extended to run multiple threads, each managing one socket and one set of clients and workers. This could be interesting for segmenting large architectures. The C code is already organized around a broker class to make this trivial.</p></li><li class="listitem"><p>A primary/failover or live/live broker reliability model is easy, as the broker essentially has no state except service presence. It's up to clients and workers to choose another broker if their first choice isn't up and running.</p></li><li class="listitem"><p>The examples use five-second heartbeats, mainly to reduce the amount of output when you enable tracing. Realistic values would be lower for most LAN applications. However, any retry has to be slow enough to allow for a service to restart, say 10 seconds at least.</p></li></ul></div><p>We later improved and extended the protocol and the Majordomo implementation, which now sits in its own Github project. If you want a properly usable Majordomo stack, use the GitHub project.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04s07.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch04.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch04s09.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Contracts and Protocols </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Asynchronous Majordomo Pattern</td></tr></table></div></body></html>
