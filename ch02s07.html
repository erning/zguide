<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Signaling Between Threads (PAIR Sockets)</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="ch02.html" title="Chapter 2. Sockets and Patterns" /><link rel="prev" href="ch02s06.html" title="Multithreading with ØMQ" /><link rel="next" href="ch02s08.html" title="Node Coordination" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Signaling Between Threads (PAIR Sockets)</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch02s06.html">Prev</a> </td><th width="60%" align="center">Chapter 2. Sockets and Patterns</th><td width="20%" align="right"> <a accesskey="n" href="ch02s08.html">Next</a></td></tr></table><hr /></div><div class="sect1" title="Signaling Between Threads (PAIR Sockets)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp19297928"></a>Signaling Between Threads (PAIR Sockets)</h2></div></div></div><p>When you start making multithreaded applications with ØMQ, you'll encounter the question of how to coordinate your threads. Though you might be tempted to insert "sleep" statements, or use multithreading techniques such as semaphores or mutexes, <span class="bold"><strong>the only mechanism that you should use are ØMQ messages</strong></span>. Remember the story of The Drunkards and The Beer Bottle.</p><p>Let's make three threads that signal each other when they are ready<a class="xref" href="ch02s07.html#figure-21" title="Figure 2.13. The Relay Race">Figure 2.13, “The Relay Race”</a>. In this example, we use PAIR sockets over the <code class="literal">inproc</code> transport:</p><div class="example"><a id="mtrelay-c"></a><p class="title"><strong>Example 2.12. Multithreaded relay (mtrelay.c)</strong></p><div class="example-contents"><pre class="programlisting">
//  Multithreaded relay

#include "zhelpers.h"
#include &lt;pthread.h&gt;

static void *
step1 (void *context) {
    //  Connect to step2 and tell it we're ready
    void *xmitter = zmq_socket (context, ZMQ_PAIR);
    zmq_connect (xmitter, "inproc://step2");
    printf ("Step 1 ready, signaling step 2\n");
    s_send (xmitter, "READY");
    zmq_close (xmitter);

    return NULL;
}

static void *
step2 (void *context) {
    //  Bind inproc socket before starting step1
    void *receiver = zmq_socket (context, ZMQ_PAIR);
    zmq_bind (receiver, "inproc://step2");
    pthread_t thread;
    pthread_create (&amp;thread, NULL, step1, context);

    //  Wait for signal and pass it on
    char *string = s_recv (receiver);
    free (string);
    zmq_close (receiver);

    //  Connect to step3 and tell it we're ready
    void *xmitter = zmq_socket (context, ZMQ_PAIR);
    zmq_connect (xmitter, "inproc://step3");
    printf ("Step 2 ready, signaling step 3\n");
    s_send (xmitter, "READY");
    zmq_close (xmitter);

    return NULL;
}

int main (void)
{
    void *context = zmq_ctx_new ();

    //  Bind inproc socket before starting step2
    void *receiver = zmq_socket (context, ZMQ_PAIR);
    zmq_bind (receiver, "inproc://step3");
    pthread_t thread;
    pthread_create (&amp;thread, NULL, step2, context);

    //  Wait for signal
    char *string = s_recv (receiver);
    free (string);
    zmq_close (receiver);

    printf ("Test successful!\n");
    zmq_ctx_destroy (context);
    return 0;
}
</pre></div></div><br class="example-break" /><div class="figure"><a id="figure-21"></a><p class="title"><strong>Figure 2.13. The Relay Race</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/fig21.png" alt="The Relay Race" /></div></div></div><br class="figure-break" /><p>This is a classic pattern for multithreading with ØMQ:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Two threads communicate over <code class="literal">inproc</code>, using a shared context.</p></li><li class="listitem"><p>The parent thread creates one socket, binds it to an <code class="literal">inproc://</code> endpoint, and <span class="emphasis"><em>then</em></span> starts the child thread, passing the context to it.</p></li><li class="listitem"><p>The child thread creates the second socket, connects it to that <code class="literal">inproc://</code> endpoint, and <span class="emphasis"><em>then</em></span> signals to the parent thread that it's ready.</p></li></ol></div><p>Note that multithreading code using this pattern is not scalable out to processes. If you use <code class="literal">inproc</code> and socket pairs, you are building a tightly-bound application, i.e., one where your threads are structurally interdependent. Do this when low latency is really vital. The other design pattern is a loosely bound application, where threads have their own context and communicate over <code class="literal">ipc</code> or <code class="literal">tcp</code>. You can easily break loosely bound threads into separate processes.</p><p>This is the first time we've shown an example using PAIR sockets. Why use PAIR? Other socket combinations might seem to work, but they all have side effects that could interfere with signaling:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>You can use PUSH for the sender and PULL for the receiver. This looks simple and will work, but remember that PUSH will distribute messages to all available receivers. If you by accident start two receivers (e.g., you already have one running and you start a second), you'll "lose" half of your signals. PAIR has the advantage of refusing more than one connection; the pair is <span class="emphasis"><em>exclusive</em></span>.</p></li><li class="listitem"><p>You can use DEALER for the sender and ROUTER for the receiver. ROUTER, however, wraps your message in an "envelope", meaning your zero-size signal turns into a multipart message. If you don't care about the data and treat anything as a valid signal, and if you don't read more than once from the socket, that won't matter. If, however, you decide to send real data, you will suddenly find ROUTER providing you with "wrong" messages. DEALER also distributes outgoing messages, giving the same risk as PUSH.</p></li><li class="listitem"><p>You can use PUB for the sender and SUB for the receiver. This will correctly deliver your messages exactly as you sent them and PUB does not distribute as PUSH or DEALER do. However, you need to configure the subscriber with an empty subscription, which is annoying.</p></li></ul></div><p>For these reasons, PAIR makes the best choice for coordination between pairs of threads.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch02s06.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch02.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch02s08.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Multithreading with ØMQ </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Node Coordination</td></tr></table></div></body></html>
