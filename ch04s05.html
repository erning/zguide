<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Robust Reliable Queuing (Paranoid Pirate Pattern)</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="ch04.html" title="Chapter 4. Reliable Request-Reply Patterns" /><link rel="prev" href="ch04s04.html" title="Basic Reliable Queuing (Simple Pirate Pattern)" /><link rel="next" href="ch04s06.html" title="Heartbeating" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Robust Reliable Queuing (Paranoid Pirate Pattern)</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04s04.html">Prev</a> </td><th width="60%" align="center">Chapter 4. Reliable Request-Reply Patterns</th><td width="20%" align="right"> <a accesskey="n" href="ch04s06.html">Next</a></td></tr></table><hr /></div><div class="sect1" title="Robust Reliable Queuing (Paranoid Pirate Pattern)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp19723208"></a>Robust Reliable Queuing (Paranoid Pirate Pattern)</h2></div></div></div><div class="figure"><a id="figure-49"></a><p class="title"><strong>Figure 4.3. The Paranoid Pirate Pattern</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/fig49.png" alt="The Paranoid Pirate Pattern" /></div></div></div><br class="figure-break" /><p>The Simple Pirate Queue pattern works pretty well, especially because it's just a combination of two existing patterns. Still, it does have some weaknesses:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>It's not robust in the face of a queue crash and restart. The client will recover, but the workers won't. While ØMQ will reconnect workers' sockets automatically, as far as the newly started queue is concerned, the workers haven't signaled ready, so don't exist. To fix this, we have to do heartbeating from queue to worker so that the worker can detect when the queue has gone away.</p></li><li class="listitem"><p>The queue does not detect worker failure, so if a worker dies while idle, the queue can't remove it from its worker queue until the queue sends it a request. The client waits and retries for nothing. It's not a critical problem, but it's not nice. To make this work properly, we do heartbeating from worker to queue, so that the queue can detect a lost worker at any stage.</p></li></ul></div><p>We'll fix these in a properly pedantic Paranoid Pirate Pattern.</p><p>We previously used a REQ socket for the worker. For the Paranoid Pirate worker, we'll switch to a DEALER socket<a class="xref" href="ch04s08.html#figure-50" title="Figure 4.4. The Majordomo Pattern">Figure 4.4, “The Majordomo Pattern”</a>. This has the advantage of letting us send and receive messages at any time, rather than the lock-step send/receive that REQ imposes. The downside of DEALER is that we have to do our own envelope management (re-read Advanced Request-Reply Patterns<a class="xref" href="ch03.html" title="Chapter 3. Advanced Request-Reply Patterns">Chapter 3, <em>Advanced Request-Reply Patterns</em></a> for background on this concept).</p><p>We're still using the Lazy Pirate client. Here is the Paranoid Pirate queue proxy:</p><div class="example"><a id="ppqueue-c"></a><p class="title"><strong>Example 4.6. Paranoid Pirate queue (ppqueue.c)</strong></p><div class="example-contents"><pre class="programlisting">
//  Paranoid Pirate queue

#include "czmq.h"
#define HEARTBEAT_LIVENESS  3       //  3-5 is reasonable
#define HEARTBEAT_INTERVAL  1000    //  msecs

//  Paranoid Pirate Protocol constants
#define PPP_READY       "\001"      //  Signals worker is ready
#define PPP_HEARTBEAT   "\002"      //  Signals worker heartbeat
</pre></div></div><br class="example-break" /><p>Here we define the worker class; a structure and a set of functions that act as constructor, destructor, and methods on worker objects: 
</p><div class="example"><a id="ppqueue-c-1"></a><p class="title"><strong>Example 4.7. Paranoid Pirate queue (ppqueue.c) - worker class structure</strong></p><div class="example-contents"><pre class="programlisting">

typedef struct {
    zframe_t *identity;         //  Identity of worker
    char *id_string;            //  Printable identity
    int64_t expiry;             //  Expires at this time
} worker_t;

//  Construct new worker
static worker_t *
s_worker_new (zframe_t *identity)
{
    worker_t *self = (worker_t *) zmalloc (sizeof (worker_t));
    self-&gt;identity = identity;
    self-&gt;id_string = zframe_strhex (identity);
    self-&gt;expiry = zclock_time ()
                 + HEARTBEAT_INTERVAL * HEARTBEAT_LIVENESS;
    return self;
}

//  Destroy specified worker object, including identity frame.
static void
s_worker_destroy (worker_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        worker_t *self = *self_p;
        zframe_destroy (&amp;self-&gt;identity);
        free (self-&gt;id_string);
        free (self);
        *self_p = NULL;
    }
}
</pre></div></div><br class="example-break" /><p>The ready method puts a worker to the end of the ready list: 
</p><div class="example"><a id="ppqueue-c-2"></a><p class="title"><strong>Example 4.8. Paranoid Pirate queue (ppqueue.c) - worker ready method</strong></p><div class="example-contents"><pre class="programlisting">

static void
s_worker_ready (worker_t *self, zlist_t *workers)
{
    worker_t *worker = (worker_t *) zlist_first (workers);
    while (worker) {
        if (streq (self-&gt;id_string, worker-&gt;id_string)) {
            zlist_remove (workers, worker);
            s_worker_destroy (&amp;worker);
            break;
        }
        worker = (worker_t *) zlist_next (workers);
    }
    zlist_append (workers, self);
}
</pre></div></div><br class="example-break" /><p>The next method returns the next available worker identity: 
</p><div class="example"><a id="ppqueue-c-3"></a><p class="title"><strong>Example 4.9. Paranoid Pirate queue (ppqueue.c) - get next available worker</strong></p><div class="example-contents"><pre class="programlisting">

static zframe_t *
s_workers_next (zlist_t *workers)
{
    worker_t *worker = zlist_pop (workers);
    assert (worker);
    zframe_t *frame = worker-&gt;identity;
    worker-&gt;identity = NULL;
    s_worker_destroy (&amp;worker);
    return frame;
}
</pre></div></div><br class="example-break" /><p>The purge method looks for and kills expired workers. We hold workers from oldest to most recent, so we stop at the first alive worker: 
</p><div class="example"><a id="ppqueue-c-4"></a><p class="title"><strong>Example 4.10. Paranoid Pirate queue (ppqueue.c) - purge expired workers</strong></p><div class="example-contents"><pre class="programlisting">

static void
s_workers_purge (zlist_t *workers)
{
    worker_t *worker = (worker_t *) zlist_first (workers);
    while (worker) {
        if (zclock_time () &lt; worker-&gt;expiry)
            break;              //  Worker is alive, we're done here

        zlist_remove (workers, worker);
        s_worker_destroy (&amp;worker);
        worker = (worker_t *) zlist_first (workers);
    }
}
</pre></div></div><br class="example-break" /><p>The main task is a load-balancer with heartbeating on workers so we can detect crashed or blocked worker tasks: 
</p><div class="example"><a id="ppqueue-c-5"></a><p class="title"><strong>Example 4.11. Paranoid Pirate queue (ppqueue.c) - main task</strong></p><div class="example-contents"><pre class="programlisting">

int main (void)
{
    zctx_t *ctx = zctx_new ();
    void *frontend = zsocket_new (ctx, ZMQ_ROUTER);
    void *backend = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (frontend, "tcp://*:5555");    //  For clients
    zsocket_bind (backend,  "tcp://*:5556");    //  For workers

    //  List of available workers
    zlist_t *workers = zlist_new ();

    //  Send out heartbeats at regular intervals
    uint64_t heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;

    while (true) {
        zmq_pollitem_t items [] = {
            { backend,  0, ZMQ_POLLIN, 0 },
            { frontend, 0, ZMQ_POLLIN, 0 }
        };
        //  Poll frontend only if we have available workers
        int rc = zmq_poll (items, zlist_size (workers)? 2: 1,
            HEARTBEAT_INTERVAL * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  Interrupted

        //  Handle worker activity on backend
        if (items [0].revents &amp; ZMQ_POLLIN) {
            //  Use worker identity for load-balancing
            zmsg_t *msg = zmsg_recv (backend);
            if (!msg)
                break;          //  Interrupted

            //  Any sign of life from worker means it's ready
            zframe_t *identity = zmsg_unwrap (msg);
            worker_t *worker = s_worker_new (identity);
            s_worker_ready (worker, workers);

            //  Validate control message, or return reply to client
            if (zmsg_size (msg) == 1) {
                zframe_t *frame = zmsg_first (msg);
                if (memcmp (zframe_data (frame), PPP_READY, 1)
                &amp;&amp;  memcmp (zframe_data (frame), PPP_HEARTBEAT, 1)) {
                    printf ("E: invalid message from worker");
                    zmsg_dump (msg);
                }
                zmsg_destroy (&amp;msg);
            }
            else
                zmsg_send (&amp;msg, frontend);
        }
        if (items [1].revents &amp; ZMQ_POLLIN) {
            //  Now get next client request, route to next worker
            zmsg_t *msg = zmsg_recv (frontend);
            if (!msg)
                break;          //  Interrupted
            zmsg_push (msg, s_workers_next (workers));
            zmsg_send (&amp;msg, backend);
        }
</pre></div></div><br class="example-break" /><p>We handle heartbeating after any socket activity. First, we send heartbeats to any idle workers if it's time. Then, we purge any dead workers: 
</p><div class="example"><a id="ppqueue-c-6"></a><p class="title"><strong>Example 4.12. Paranoid Pirate queue (ppqueue.c) - handle heartbeating</strong></p><div class="example-contents"><pre class="programlisting">
            worker_t *worker = (worker_t *) zlist_first (workers);
            while (worker) {
                zframe_send (&amp;worker-&gt;identity, backend,
                             ZFRAME_REUSE + ZFRAME_MORE);
                zframe_t *frame = zframe_new (PPP_HEARTBEAT, 1);
                zframe_send (&amp;frame, backend, 0);
                worker = (worker_t *) zlist_next (workers);
            }
            heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;
        }
        s_workers_purge (workers);
    }
    //  When we're done, clean up properly
    while (zlist_size (workers)) {
        worker_t *worker = (worker_t *) zlist_pop (workers);
        s_worker_destroy (&amp;worker);
    }
    zlist_destroy (&amp;workers);
    zctx_destroy (&amp;ctx);
    return 0;
}
</pre></div></div><br class="example-break" /><p>The queue extends the load balancing pattern with heartbeating of workers. Heartbeating is one of those "simple" things that can be difficult to get right. I'll explain more about that in a second.</p><p>Here is the Paranoid Pirate worker:</p><div class="example"><a id="ppworker-c"></a><p class="title"><strong>Example 4.13. Paranoid Pirate worker (ppworker.c)</strong></p><div class="example-contents"><pre class="programlisting">
//  Paranoid Pirate worker

#include "czmq.h"
#define HEARTBEAT_LIVENESS  3       //  3-5 is reasonable
#define HEARTBEAT_INTERVAL  1000    //  msecs
#define INTERVAL_INIT       1000    //  Initial reconnect
#define INTERVAL_MAX       32000    //  After exponential backoff

//  Paranoid Pirate Protocol constants
#define PPP_READY       "\001"      //  Signals worker is ready
#define PPP_HEARTBEAT   "\002"      //  Signals worker heartbeat

//  Helper function that returns a new configured socket
//  connected to the Paranoid Pirate queue

static void *
s_worker_socket (zctx_t *ctx) {
    void *worker = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (worker, "tcp://localhost:5556");

    //  Tell queue we're ready for work
    printf ("I: worker ready\n");
    zframe_t *frame = zframe_new (PPP_READY, 1);
    zframe_send (&amp;frame, worker, 0);

    return worker;
}
</pre></div></div><br class="example-break" /><p>We have a single task that implements the worker side of the Paranoid Pirate Protocol (PPP). The interesting parts here are the heartbeating, which lets the worker detect if the queue has died, and vice versa: 
</p><div class="example"><a id="ppworker-c-1"></a><p class="title"><strong>Example 4.14. Paranoid Pirate worker (ppworker.c) - main task</strong></p><div class="example-contents"><pre class="programlisting">

int main (void)
{
    zctx_t *ctx = zctx_new ();
    void *worker = s_worker_socket (ctx);

    //  If liveness hits zero, queue is considered disconnected
    size_t liveness = HEARTBEAT_LIVENESS;
    size_t interval = INTERVAL_INIT;

    //  Send out heartbeats at regular intervals
    uint64_t heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;

    srandom ((unsigned) time (NULL));
    int cycles = 0;
    while (true) {
        zmq_pollitem_t items [] = { { worker,  0, ZMQ_POLLIN, 0 } };
        int rc = zmq_poll (items, 1, HEARTBEAT_INTERVAL * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  Interrupted

        if (items [0].revents &amp; ZMQ_POLLIN) {
            //  Get message
            //  - 3-part envelope + content -&gt; request
            //  - 1-part HEARTBEAT -&gt; heartbeat
            zmsg_t *msg = zmsg_recv (worker);
            if (!msg)
                break;          //  Interrupted
</pre></div></div><br class="example-break" /><p>To test the robustness of the queue implementation we simulate various typical problems, such as the worker crashing or running very slowly. We do this after a few cycles so that the architecture can get up and running first: 
</p><div class="example"><a id="ppworker-c-2"></a><p class="title"><strong>Example 4.15. Paranoid Pirate worker (ppworker.c) - simulating problems</strong></p><div class="example-contents"><pre class="programlisting">

                cycles++;
                if (cycles &gt; 3 &amp;&amp; randof (5) == 0) {
                    printf ("I: simulating a crash\n");
                    zmsg_destroy (&amp;msg);
                    break;
                }
                else
                if (cycles &gt; 3 &amp;&amp; randof (5) == 0) {
                    printf ("I: simulating CPU overload\n");
                    sleep (3);
                    if (zctx_interrupted)
                        break;
                }
                printf ("I: normal reply\n");
                zmsg_send (&amp;msg, worker);
                liveness = HEARTBEAT_LIVENESS;
                sleep (1);              //  Do some heavy work
                if (zctx_interrupted)
                    break;
            }
            else
</pre></div></div><br class="example-break" /><p>When we get a heartbeat message from the queue, it means the queue was (recently) alive, so we must reset our liveness indicator: 
</p><div class="example"><a id="ppworker-c-3"></a><p class="title"><strong>Example 4.16. Paranoid Pirate worker (ppworker.c) - handle heartbeats</strong></p><div class="example-contents"><pre class="programlisting">
                zframe_t *frame = zmsg_first (msg);
                if (memcmp (zframe_data (frame), PPP_HEARTBEAT, 1) == 0)
                    liveness = HEARTBEAT_LIVENESS;
                else {
                    printf ("E: invalid message\n");
                    zmsg_dump (msg);
                }
                zmsg_destroy (&amp;msg);
            }
            else {
                printf ("E: invalid message\n");
                zmsg_dump (msg);
            }
            interval = INTERVAL_INIT;
        }
        else
</pre></div></div><br class="example-break" /><p>If the queue hasn't sent us heartbeats in a while, destroy the socket and reconnect. This is the simplest most brutal way of discarding any messages we might have sent in the meantime: 
</p><div class="example"><a id="ppworker-c-4"></a><p class="title"><strong>Example 4.17. Paranoid Pirate worker (ppworker.c) - detecting a dead queue</strong></p><div class="example-contents"><pre class="programlisting">
            printf ("W: heartbeat failure, can't reach queue\n");
            printf ("W: reconnecting in %zd msec...\n", interval);
            zclock_sleep (interval);

            if (interval &lt; INTERVAL_MAX)
                interval *= 2;
            zsocket_destroy (ctx, worker);
            worker = s_worker_socket (ctx);
            liveness = HEARTBEAT_LIVENESS;
        }
        //  Send heartbeat to queue if it's time
        if (zclock_time () &gt; heartbeat_at) {
            heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;
            printf ("I: worker heartbeat\n");
            zframe_t *frame = zframe_new (PPP_HEARTBEAT, 1);
            zframe_send (&amp;frame, worker, 0);
        }
    }
    zctx_destroy (&amp;ctx);
    return 0;
}
</pre></div></div><br class="example-break" /><p>Some comments about this example:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The code includes simulation of failures, as before. This makes it (a) very hard to debug, and (b) dangerous to reuse. When you want to debug this, disable the failure simulation.</p></li><li class="listitem"><p>The worker uses a reconnect strategy similar to the one we designed for the Lazy Pirate client, with two major differences: (a) it does an exponential back-off, and (b) it retries indefinitely (whereas the client retries a few times before reporting a failure).</p></li></ul></div><p>Try the client, queue, and workers, such as by using a script like this:</p><pre class="screen">ppqueue &amp;
for i in 1 2 3 4; do
    ppworker &amp;
    sleep 1
done
lpclient &amp;
</pre><p>You should see the workers die one-by-one as they simulate a crash, and the client eventually give up. You can stop and restart the queue and both client and workers will reconnect and carry on. And no matter what you do to queues and workers, the client will never get an out-of-order reply: the whole chain either works, or the client abandons.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04s04.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch04.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch04s06.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Basic Reliable Queuing (Simple Pirate Pattern) </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Heartbeating</td></tr></table></div></body></html>
