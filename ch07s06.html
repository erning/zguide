<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Authentication Using SASL</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="ch07.html" title="Chapter 7. Advanced Architecture using ØMQ" /><link rel="prev" href="ch07s05.html" title="State Machines" /><link rel="next" href="ch07s07.html" title="Large-Scale File Publishing: FileMQ" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Authentication Using SASL</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch07s05.html">Prev</a> </td><th width="60%" align="center">Chapter 7. Advanced Architecture using ØMQ</th><td width="20%" align="right"> <a accesskey="n" href="ch07s07.html">Next</a></td></tr></table><hr /></div><div class="sect1" title="Authentication Using SASL"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp21036864"></a>Authentication Using SASL</h2></div></div></div><p>When we designed AMQP in 2007, we chose the <a class="ulink" href="http://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer" target="_top">Simple Authentication and Security Layer</a> (SASL) for the authentication layer, one of the ideas we took from the <a class="ulink" href="http://www.rfc-editor.org/rfc/rfc3080.txt" target="_top">BEEP protocol framework</a>. SASL looks complex at first, but it's actually simple and fits neatly into a ØMQ-based protocol. What I especially like about SASL is that it's scalable. You can start with anonymous access or plain text authentication and no security, and grow to more secure mechanisms over time without changing your protocol.</p><p>I'm not going to give a deep explanation now because we'll see SASL in action somewhat later. But I'll explain the principle so you're already somewhat prepared.</p><p>In the NOM protocol, the client started with an OHAI command, which the server either accepted ("Hi Joe!") or rejected. This is simple but not scalable because server and client have to agree up-front on the type of authentication they're going to do.</p><p>What SASL introduced, which is genius, is a fully abstracted and negotiable security layer that's still easy to implement at the protocol level. It works as follows:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The client connects.</p></li><li class="listitem"><p>The server challenges the client, passing a list of security "mechanisms" that it knows about.</p></li><li class="listitem"><p>The client chooses a security mechanism that it knows about, and answers the server's challenge with a blob of opaque data that (and here's the neat trick) some generic security library calculates and gives to the client.</p></li><li class="listitem"><p>The server takes the security mechanism the client chose, and that blob of data, and passes it to its own security library.</p></li><li class="listitem"><p>The library either accepts the client's answer, or the server challenges again.</p></li></ul></div><p>There are a number of free SASL libraries. When we come to real code, we'll implement just two mechanisms, ANONYMOUS and PLAIN, which don't need any special libraries.</p><p>To support SASL, we have to add an optional challenge/response step to our "open-peering" flow. Here is what the resulting protocol grammar looks like (I'm modifying NOM to do this):</p><pre class="screen">secure-nom      = open-peering *use-peering

open-peering    = C:OHAI *( S:ORLY C:YARLY ) ( S:OHAI-OK / S:WTF )

ORLY            = 1*mechanism challenge
mechanism       = string
challenge       = *OCTET

YARLY           = mechanism response
response        = *OCTET
</pre><p>Where ORLY and YARLY contain a string (a list of mechanisms in ORLY, one mechanism in YARLY) and a blob of opaque data. Depending on the mechanism, the initial challenge from the server may be empty. We don't care: we just pass this to the security library to deal with.</p><p>The SASL <a class="ulink" href="http://tools.ietf.org/html/rfc4422" target="_top">RFC</a> goes into detail about other features (that we don't need), the kinds of ways SASL could be attacked, and so on.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch07s05.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch07.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch07s07.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">State Machines </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Large-Scale File Publishing: FileMQ</td></tr></table></div></body></html>
