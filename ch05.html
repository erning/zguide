<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 5. Advanced Pub-Sub Patterns</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="prev" href="ch04s15.html" title="Conclusion" /><link rel="next" href="ch05s02.html" title="Pub-Sub Tracing (Espresso Pattern)" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 5. Advanced Pub-Sub Patterns</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04s15.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch05s02.html">Next</a></td></tr></table><hr /></div><div class="chapter" title="Chapter 5. Advanced Pub-Sub Patterns"><div class="titlepage"><div><div><h2 class="title"><a id="advanced-pub-sub"></a>Chapter 5. Advanced Pub-Sub Patterns</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="sect1"><a href="ch05.html#idp20164648">Pros and Cons of Pub-Sub</a></span></dt><dt><span class="sect1"><a href="ch05s02.html">Pub-Sub Tracing (Espresso Pattern)</a></span></dt><dt><span class="sect1"><a href="ch05s03.html">Last Value Caching</a></span></dt><dt><span class="sect1"><a href="ch05s04.html">Slow Subscriber Detection (Suicidal Snail Pattern)</a></span></dt><dt><span class="sect1"><a href="ch05s05.html">High-Speed Subscribers (Black Box Pattern)</a></span></dt><dt><span class="sect1"><a href="ch05s06.html">Reliable Pub-Sub (Clone Pattern)</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch05s06.html#idp20244256">Centralized Versus Decentralized</a></span></dt><dt><span class="sect2"><a href="ch05s06.html#idp20248160">Representing State as Key-Value Pairs</a></span></dt><dt><span class="sect2"><a href="ch05s06.html#idp20290080">Getting an Out-of-Band Snapshot</a></span></dt><dt><span class="sect2"><a href="ch05s06.html#idp20310304">Republishing Updates from Clients</a></span></dt><dt><span class="sect2"><a href="ch05s06.html#idp20333464">Working with Subtrees</a></span></dt><dt><span class="sect2"><a href="ch05s06.html#idp20345008">Ephemeral Values</a></span></dt><dt><span class="sect2"><a href="ch05s06.html#idp20381608">Using a Reactor</a></span></dt><dt><span class="sect2"><a href="ch05s06.html#idp20401168">Adding the Binary Star Pattern for Reliability</a></span></dt><dt><span class="sect2"><a href="ch05s06.html#idp20450736">The Clustered Hashmap Protocol</a></span></dt><dt><span class="sect2"><a href="ch05s06.html#idp20474528">Building a Multithreaded Stack and API</a></span></dt></dl></dd></dl></div><p>In Advanced Request-Reply Patterns<a class="xref" href="ch03.html" title="Chapter 3. Advanced Request-Reply Patterns">Chapter 3, <em>Advanced Request-Reply Patterns</em></a> and Reliable Request-Reply Patterns<a class="xref" href="ch04.html" title="Chapter 4. Reliable Request-Reply Patterns">Chapter 4, <em>Reliable Request-Reply Patterns</em></a> we looked at advanced use of ØMQ's request-reply pattern. If you managed to digest all that, congratulations. In this chapter we'll focus on publish-subscribe and extend ØMQ's core pub-sub pattern with higher-level patterns for performance, reliability, state distribution, and monitoring.</p><p>We'll cover:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>When to use publish-subscribe</p></li><li class="listitem"><p>How to handle too-slow subscribers (the <span class="emphasis"><em>Suicidal Snail</em></span> pattern)</p></li><li class="listitem"><p>How to design high-speed subscribers (the <span class="emphasis"><em>Black Box</em></span> pattern)</p></li><li class="listitem"><p>How to monitor a pub-sub network (the <span class="emphasis"><em>Espresso</em></span> pattern)</p></li><li class="listitem"><p>How to build a shared key-value store (the <span class="emphasis"><em>Clone</em></span> pattern)</p></li><li class="listitem"><p>How to use reactors to simplify complex servers</p></li><li class="listitem"><p>How to use the Binary Star pattern to add failover to a server</p></li></ul></div><div class="sect1" title="Pros and Cons of Pub-Sub"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp20164648"></a>Pros and Cons of Pub-Sub</h2></div></div></div><p>ØMQ's low-level patterns have their different characters. Pub-sub addresses an old messaging problem, which is <span class="emphasis"><em>multicast</em></span> or <span class="emphasis"><em>group messaging</em></span>. It has that unique mix of meticulous simplicity and brutal indifference that characterizes ØMQ. It's worth understanding the trade-offs that pub-sub makes, how these benefit us, and how we can work around them if needed.</p><p>First, PUB sends each message to "all of many", whereas PUSH and DEALER rotate messages to "one of many". You cannot simply replace PUSH with PUB or vice versa and hope that things will work. This bears repeating because people seem to quite often suggest doing this.</p><p>More profoundly, pub-sub is aimed at scalability. This means large volumes of data, sent rapidly to many recipients. If you need millions of messages per second sent to thousands of points, you'll appreciate pub-sub a lot more than if you need a few messages a second sent to a handful of recipients.</p><p>To get scalability, pub-sub uses the same trick as push-pull, which is to get rid of back-chatter. This means that recipients don't talk back to senders. There are some exceptions, e.g., SUB sockets will send subscriptions to PUB sockets, but it's anonymous and infrequent.</p><p>Killing back-chatter is essential to real scalability. With pub-sub, it's how the pattern can map cleanly to the PGM multicast protocol, which is handled by the network switch. In other words, subscribers don't connect to the publisher at all, they connect to a multicast <span class="emphasis"><em>group</em></span> on the switch, to which the publisher sends its messages.</p><p>When we remove back-chatter, our overall message flow becomes <span class="emphasis"><em>much</em></span> simpler, which lets us make simpler APIs, simpler protocols, and in general reach many more people. But we also remove any possibility to coordinate senders and receivers. What this means is:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Publishers can't tell when subscribers are successfully connected, both on initial connections, and on reconnections after network failures.</p></li><li class="listitem"><p>Subscribers can't tell publishers anything that would allow publishers to control the rate of messages they send. Publishers only have one setting, which is <span class="emphasis"><em>full-speed</em></span>, and subscribers must either keep up or lose messages.</p></li><li class="listitem"><p>Publishers can't tell when subscribers have disappeared due to processes crashing, networks breaking, and so on.</p></li></ul></div><p>The downside is that we actually need all of these if we want to do reliable multicast. The ØMQ pub-sub pattern will lose messages arbitrarily when a subscriber is connecting, when a network failure occurs, or just if the subscriber or network can't keep up with the publisher.</p><p>The upside is that there are many use cases where <span class="emphasis"><em>almost</em></span> reliable multicast is just fine. When we need this back-chatter, we can either switch to using ROUTER-DEALER (which I tend to do for most normal volume cases), or we can add a separate channel for synchronization (we'll see an example of this later in this chapter).</p><p>Pub-sub is like a radio broadcast; you miss everything before you join, and then how much information you get depends on the quality of your reception. Surprisingly, this model is useful and widespread because it maps perfectly to real world distribution of information. Think of Facebook and Twitter, the BBC World Service, and the sports results.</p><p>As we did for request-reply, let's define <span class="emphasis"><em>reliability</em></span> in terms of what can go wrong. Here are the classic failure cases for pub-sub:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Subscribers join late, so they miss messages the server already sent.</p></li><li class="listitem"><p>Subscribers can fetch messages too slowly, so queues build up and then overflow.</p></li><li class="listitem"><p>Subscribers can drop off and lose messages while they are away.</p></li><li class="listitem"><p>Subscribers can crash and restart, and lose whatever data they already received.</p></li><li class="listitem"><p>Networks can become overloaded and drop data (specifically, for PGM).</p></li><li class="listitem"><p>Networks can become too slow, so publisher-side queues overflow and publishers crash.</p></li></ul></div><p>A lot more can go wrong but these are the typical failures we see in a realistic system. Since v3.x, ØMQ forces default limits on its internal buffers (the so-called high-water mark or HWM), so publisher crashes are rarer unless you deliberately set the HWM to infinite.</p><p>All of these failure cases have answers, though not always simple ones. Reliability requires complexity that most of us don't need, most of the time, which is why ØMQ doesn't attempt to provide it out of the box (even if there was one global design for reliability, which there isn't).</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04s15.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch05s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Conclusion </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Pub-Sub Tracing (Espresso Pattern)</td></tr></table></div></body></html>
