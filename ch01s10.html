<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>我们为什么需要ØMQ</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="ch01.html" title="Chapter 1. ØMQ基础" /><link rel="prev" href="ch01s09.html" title="使用ØMQ编程" /><link rel="next" href="ch01s11.html" title="套接字的扩展性" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">我们为什么需要ØMQ</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch01s09.html">Prev</a> </td><th width="60%" align="center">Chapter 1. ØMQ基础</th><td width="20%" align="right"> <a accesskey="n" href="ch01s11.html">Next</a></td></tr></table><hr /></div><div class="sect1" title="我们为什么需要ØMQ"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp19034576"></a>我们为什么需要ØMQ</h2></div></div></div><p>现在我们已经将ØMQ运行起来了，让我们回顾一下为什么我们需要ØMQ：</p><p>目前的应用程序很多都会包含跨网络的组件，无论是局域网还是因特网。这些程序的开发者都会用到某种消息通信机制。有些人会使用某种消息队列产品，而大多数人则会自己手工来做这些事，使用TCP或UDP协议。这些协议使用起来并不困难，但是，简单地将消息从A发给B，和在任何情况下都能进行可靠的消息传输，这两种情况显然是不同的。</p><p>让我们看看在使用纯TCP协议进行消息传输时会遇到的一些典型问题。任何可复用的消息传输层肯定或多或少地会要解决以下问题：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>如何处理I/O？是让程序阻塞等待响应，还是在后台处理这些事？这是软件设计的关键因素。阻塞式的I/O操作会让程序架构难以扩展，而后台处理I/O也是比较困难的。</p></li><li class="listitem"><p>如何处理那些临时的、来去自由的组件？我们是否要将组件分为客户端和服务端两种，并要求服务端永不消失？那如果我们想要将服务端相连怎么办？我们要每隔几秒就进行重连吗？</p></li><li class="listitem"><p>我们如何表示一条消息？我们怎样通过拆分消息，让其变得易读易写，不用担心缓存溢出，既能高效地传输小消息，又能胜任视频等大型文件的传输？</p></li><li class="listitem"><p>如何处理那些不能立刻发送出去的消息？比如我们需要等待一个网络组件重新连接的时候？我们是直接丢弃该条消息，还是将它存入数据库，或是内存中的一个队列？</p></li><li class="listitem"><p>要在哪里保存消息队列？如果某个组件读取消息队列的速度很慢，造成消息的堆积怎么办？我们要采取什么样的策略？</p></li><li class="listitem"><p>如何处理丢失的消息？我们是等待新的数据，请求重发，还是需要建立一套新的可靠性机制以保证消息不会丢失？如果这个机制自身崩溃了呢？</p></li><li class="listitem"><p>如果我们想换一种网络连接协议，如用广播代替TCP单播？或者改用IPv6？我们是否需要重写所有的应用程序，或者将这种协议抽象到一个单独的层中？</p></li><li class="listitem"><p>我们如何对消息进行路由？我们可以将消息同时发送给多个节点吗？是否能将应答消息返回给请求的发送方？</p></li><li class="listitem"><p>我们如何为另一种语言写一个API？我们是否需要完全重写某项协议，还是重新打包一个类库？</p></li><li class="listitem"><p>怎样才能做到在不同的架构之间传送消息？是否需要为消息规定一种编码？</p></li><li class="listitem"><p>我们如何处理网络通信错误？等待并重试，还是直接忽略或取消？</p></li></ul></div><p>我们可以找一个开源软件来做例子，如<a class="ulink" href="http://hadoop.apache.org/zookeeper/" target="_top">Hadoop Zookeeper</a>，看一下它的C语言API源码，<code class="literal"><a class="ulink" href="http://github.com/apache/zookeeper/blob/trunk/src/c/src/zookeeper.c" target="_top">src/c/src/zookeeper.c</a></code>。2013年1月时，这段代码大约有4,200行，没有注释，实现了一个C/S网络通信协议。它工作起来很高效，因为使用了<code class="literal">poll()</code>来代替<code class="literal">select()</code>。但是，Zookeeper应该被抽象出来，作为一种通用的消息通信层，并加以详细的注释。像这样的模块应该得到最大程度上的复用，而不是重复地制造轮子。</p><p>但是，如何编写这样一个可复用的消息层呢？为什么长久以来人们宁愿在自己的代码中重复书写控制原始TCP套接字的代码，而不愿编写这样一个公共库呢？</p><p><a class="xref" href="ch01s10.html#figure-7" title="Figure 1.6. Messaging as it Starts">Figure 1.6, “Messaging as it Starts”</a>?</p><p>其实，要编写一个通用的消息层是件非常困难的事，这也是为什么FOSS项目不断在尝试，一些商业化的消息产品如此之复杂、昂贵、僵硬、脆弱。2006年，iMatix设计了<a class="ulink" href="http://www.amqp.org" target="_top">AMQP</a>协议，为FOSS项目的开发者提供了可能是当时第一个可复用的消息系统。AMQP比其他同类产品要来得好，但(http://www.imatix.com/articles:whats-wrong-with-amqp 仍然是复杂、昂贵和脆弱的)。它需要花费几周的时间去学习，花费数月的时间去创建一个真正能用的架构，到那时可能为时已晚了。</p><div class="figure"><a id="figure-7"></a><p class="title"><strong>Figure 1.6. Messaging as it Starts</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/fig7.png" alt="Messaging as it Starts" /></div></div></div><br class="figure-break" /><p>Most messaging projects, like AMQP, that try to solve this long list of problems in a reusable way do so by inventing a new concept, the "broker", that does addressing, routing, and queuing. This results in a client/server protocol or a set of APIs on top of some undocumented protocol that allows applications to speak to this broker. Brokers are an excellent thing in reducing the complexity of large networks. But adding broker-based messaging to a product like Zookeeper would make it worse, not better. It would mean adding an additional big box, and a new single point of failure. A broker rapidly becomes a bottleneck and a new risk to manage. If the software supports it, we can add a second, third, and fourth broker and make some failover scheme. People do this. It creates more moving pieces, more complexity, and more things to break.</p><p>And a broker-centric setup needs its own operations team. You literally need to watch the brokers day and night, and beat them with a stick when they start misbehaving. You need boxes, and you need backup boxes, and you need people to manage those boxes. It is only worth doing for large applications with many moving pieces, built by several teams of people over several years.</p><div class="figure"><a id="figure-8"></a><p class="title"><strong>Figure 1.7. Messaging as it Becomes</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/fig8.png" alt="Messaging as it Becomes" /></div></div></div><br class="figure-break" /><p>So small to medium application developers are trapped. Either they avoid network programming and make monolithic applications that do not scale. Or they jump into network programming and make brittle, complex applications that are hard to maintain. Or they bet on a messaging product, and end up with scalable applications that depend on expensive, easily broken technology. There has been no really good choice, which is maybe why messaging is largely stuck in the last century and stirs strong emotions: negative ones for users, gleeful joy for those selling support and licenses<a class="xref" href="ch02.html#figure-9" title="Figure 2.1. TCP sockets are 1 to 1">Figure 2.1, “TCP sockets are 1 to 1”</a>.</p><p>我们真正需要的是这样一种消息软件，它能够做大型消息软件所能做的一切，但使用起来又非常简单，成本很低，可以用到所有的应用程序中，没有任何依赖条件。因为没有了额外的模块，就降低了出错的概率。这种软件需要能够在所有的操作系统上运行，并能支持所有的编程语言。</p><p>ØMQ就是这样一种软件：它高效，提供了嵌入式的类库，使应用程序能够很好地在网络中扩展，成本低廉。</p><p>ØMQ主要特点有：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>ØMQ会在后台线程异步地处理I/O操作，它使用一种不会死锁的数据结构来存储消息。</p></li><li class="listitem"><p>网络组件可以来去自如，ØMQ会负责自动重连，这就意味着你可以以任何顺序启动组件；用它创建的面向服务架构（SOAs）中，服务端可以随意地加入或退出网络。</p></li><li class="listitem"><p>ØMQ会在有必要的情况下自动将消息放入队列中保存，一旦建立了连接就开始发送。</p></li><li class="listitem"><p>ØMQ有阈值（HWM）的机制，可以避免消息溢出。当队列已满，ØMQ会自动阻塞发送者，或丢弃部分消息，这些行为取决于你所使用的消息模式。</p></li><li class="listitem"><p>ØMQ可以让你用不同的通信协议进行连接，如TCP、广播、进程内、进程间。改变通信协议时你不需要去修改代码。</p></li><li class="listitem"><p>ØMQ会恰当地处理速度较慢的节点，会根据消息模式使用不同的策略。</p></li><li class="listitem"><p>ØMQ提供了多种模式进行消息路由，如请求-应答模式、发布-订阅模式等。这些模式可以用来搭建网络拓扑结构。</p></li><li class="listitem"><p>ØMQ中可以根据消息模式建立起一些中间装置（很小巧），可以用来降低网络的复杂程度。</p></li><li class="listitem"><p>ØMQ会发送整个消息，使用消息帧的机制来传递。如果你发送了10KB大小的消息，你就会收到10KB大小的消息。</p></li><li class="listitem"><p>ØMQ不强制使用某种消息格式，消息可以是0字节的，或是大到GB级的数据。当你表示这些消息时，可以选用诸如谷歌的protocol buffers，XDR等序列化产品。</p></li><li class="listitem"><p>ØMQ能够智能地处理网络错误，有时它会进行重试，有时会告知你某项操作发生了错误。</p></li><li class="listitem"><p>ØMQ甚至可以降低对环境的污染，因为节省了CPU时间意味着节省了电能。</p></li></ul></div><p>其实ØMQ可以做的还不止这些，它会颠覆人们编写网络应用程序的模式。虽然从表面上看，它不过是提供了一套处理套接字的API，能够用zmq_recv()和zmq_send()进行消息的收发，但是，消息处理将成为应用程序的核心部分，很快你的程序就会变成一个个消息处理模块，这既美观又自然。它的扩展性还很强，每项任务由一个节点（节点是一个线程）、同一台机器上的两个节点（节点是一个进程）、同一网络上的两台机器（节点是一台机器）来处理，而不需要改动应用程序。</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch01s09.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch01.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch01s11.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">使用ØMQ编程 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 套接字的扩展性</td></tr></table></div></body></html>
