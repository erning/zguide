<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>A Real-Life Example</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="ch06.html" title="Chapter 6. The ØMQ Community" /><link rel="prev" href="ch06s03.html" title="The ØMQ Process: C4" /><link rel="next" href="ch06s05.html" title="Git Branches Considered Harmful" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">A Real-Life Example</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch06s03.html">Prev</a> </td><th width="60%" align="center">Chapter 6. The ØMQ Community</th><td width="20%" align="right"> <a accesskey="n" href="ch06s05.html">Next</a></td></tr></table><hr /></div><div class="sect1" title="A Real-Life Example"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp20692688"></a>A Real-Life Example</h2></div></div></div><p>In <a class="ulink" href="http://lists.zeromq.org/pipermail/zeromq-dev/2012-October/018838.html" target="_top">this email thread</a>, Dan Goes asks how to make a publisher that knows when a new client subscribes, and sends out previous matching messages. It's a standard pub-sub technique called "last value caching". Now over a 1-way transport like pgm (where subscribers literally send no packets back to publishers), this can't be done. But over TCP, it can, if we use an XPUB socket and if that socket didn't cleverly filter out duplicate subscriptions to reduce upstream traffic.</p><p>Though I'm not an expert contributor to <code class="literal">libzmq</code>, this seems like a fun problem to solve. How hard could it be? I start by forking the <code class="literal">libzmq</code> repository to my own GitHub account and then clone it to my laptop, where I build it:</p><pre class="screen">git clone git@github.com:hintjens/libzmq.git
cd libzmq
./autogen.sh
./configure
make
</pre><p>Because the <code class="literal">libzmq</code> code is neat and well-organized, it was quite easy to find the main files to change (<code class="literal">xpub.cpp</code> and <code class="literal">xpub.hpp</code>). Each socket type has its own source file and class. They inherit from <code class="literal">socket_base.cpp</code>, which has this hook for socket-specific options:</p><pre class="screen">//  First, check whether specific socket type overloads the option.
int rc = xsetsockopt (option_, optval_, optvallen_);
if (rc == 0 || errno != EINVAL)
    return rc;

//  If the socket type doesn't support the option, pass it to
//  the generic option parser.
return options.setsockopt (option_, optval_, optvallen_);
</pre><p>Then I check where the XPUB socket filters out duplicate subscriptions, in its <code class="literal">xread_activated</code> method:</p><pre class="screen">bool unique;
if (*data == 0)
    unique = subscriptions.rm (data + 1, size - 1, pipe_);
else
    unique = subscriptions.add (data + 1, size - 1, pipe_);

//  If the subscription is not a duplicate store it so that it can be
//  passed to used on next recv call.
if (unique &amp;&amp; options.type != ZMQ_PUB)
    pending.push_back (blob_t (data, size));
</pre><p>At this stage, I'm not too concerned with the details of how <code class="literal">subscriptions.rm</code> and <code class="literal">subscriptions.add</code> work. The code seems obvious except that "subscription" also includes unsubscription, which confused me for a few seconds. If there's anything else weird in the rm and add methods, that's a separate issue to fix later. Time to make an issue for this change. I head over to the <code class="literal">zeromq.jira.com</code> site, log in, and create a new entry.</p><p>Jira kindly offers me the traditional choice between "bug" and "new feature" and I spend thirty seconds wondering where this counterproductive historical distinction came from. Presumably, the "we'll fix bugs for free, but you pay for new features" commercial proposal, which stems from the "you tell us what you want and we'll make it for $X" model of software development, and which generally leads to "we spent three times $X and we got what?!" email Fists of Fury.</p><p>Putting such thoughts aside, I create <a class="ulink" href="https://zeromq.jira.com/browse/LIBZMQ-443" target="_top">an issue #443</a> and described the problem and plausible solution:</p><div class="blockquote"><blockquote class="blockquote"><p>Problem: XPUB socket filters out duplicate subscriptions (deliberate design). However this makes it impossible to do subscription-based intelligence. See http://lists.zeromq.org/pipermail/zeromq-dev/2012-October/018838.html for a use case.</p><p>Solution: make this behavior configurable with a socket option.</p></blockquote></div><p>It's naming time. The API sits in <code class="literal">include/zmq.h</code>, so this is where I added the option name. When you invent a concept in an API or anywhere, <span class="emphasis"><em>please</em></span> take a moment to choose a name that is explicit and short and obvious. Don't fall back on generic names that need additional context to understand. You have one chance to tell the reader what your concept is and does. A name like <code class="literal">ZMQ_SUBSCRIPTION_FORWARDING_FLAG</code> is terrible. It technically kind of aims in the right direction, but is miserably long and obscure. I chose <code class="literal">ZMQ_XPUB_VERBOSE</code>: short and explicit and clearly an on/off switch with "off" being the default setting.</p><p>So, it's time to add a private property to the <code class="literal">xpub</code> class definition in <code class="literal">xpub.hpp</code>:</p><pre class="screen">// If true, send all subscription messages upstream, not just
// unique ones
bool verbose;
</pre><p>And then lift some code from <code class="literal">router.cpp</code> to implement the <code class="literal">xsetsockopt</code> method. Finally, change the <code class="literal">xread_activated</code> method to use this new option, and while at it, make that test on socket type more explicit too:</p><pre class="screen">//  If the subscription is not a duplicate store it so that it can be
//  passed to used on next recv call.
if (options.type == ZMQ_XPUB &amp;&amp; (unique || verbose))
    pending.push_back (blob_t (data, size));
</pre><p>The thing builds nicely the first time. This makes me a little suspicious, but being lazy and jet-lagged I don't immediately make a test case to actually try out the change. The process doesn't demand that, even if usually I'd do it just to catch that inevitable 10% of mistakes we all make. I do however document this new option on the <code class="literal">doc/zmq_setsockopt.txt</code> man page. In the worst case, I added a patch that wasn't really useful. But I certainly didn't break anything.</p><p>I don't implement a matching <code class="literal">zmq_getsockopt</code> because "minimal" means what it says. There's no obvious use case for getting the value of an option that you presumably just set, in code. Symmetry isn't a valid reason to double the size of a patch. I did have to document the new option because the process says, "All Public Contracts SHOULD be documented."</p><p>Committing the code, I push the patch to my forked repository (the "origin"):</p><pre class="screen">git commit -a -m "Fixed issue #443"
git push origin master
</pre><p>Switching to the GitHub web interface, I go to my <code class="literal">libzmq</code> fork, and press the big "Pull Request" button at the top. GitHub asks me for a title, so I enter "Added ZMQ_XPUB_VERBOSE option". I'm not sure why it asks this as I made a neat commit message but hey, let's go with the flow here.</p><p>This makes a nice little pull request with two commits; the one I'd made a month ago on the release notes to prepare for the v3.2.1 release (a month passes so quickly when you spend most of it in airports), and my fix for issue #443 (37 new lines of code). GitHub lets you continue to make commits after you've kicked off a pull request. They get queued up and merged in one go. That is easy, but the maintainer may refuse the whole bundle based on one patch that doesn't look valid.</p><p>Because Dan is waiting (at least in my highly optimistic imagination) for this fix, I go back to the zeromq-dev list and tell him I've made the patch, with a link to the commit. The faster I get feedback, the better. It's 1 a.m. in South Korea as I make this patch, so early evening in Europe, and morning in the States. You learn to count timezones when you work with people across the world. Ian is in a conference, Mikko is getting on a plane, and Chuck is probably in the office, but three hours later, Ian merges the pull request.</p><p>After Ian merges the pull request, I resynchronize my fork with the upstream <code class="literal">libzmq</code> repository. First, I add a <span class="emphasis"><em>remote</em></span> that tells git where this repository sits (I do this just once in the directory where I'm working):</p><pre class="screen">git remote add upstream git://github.com/zeromq/libzmq.git
</pre><p>And then I pull changes back from the upstream master and check the git log to double-check:</p><pre class="screen">git pull --rebase upstream master
git log
</pre><p>And that is pretty much it, in terms of how much git one needs to learn and use to contribute patches to <code class="literal">libzmq</code>. Six git commands and some clicking on web pages. Most importantly to me as a naturally lazy, stupid, and easily confused developer, I don't have to learn git's internal models, and never have to do anything involving those infernal engines of structural complexity we call "git branches". Next up, the attempted assassination of git branches. Let's live dangerously!</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch06s03.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch06.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch06s05.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">The ØMQ Process: C4 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Git Branches Considered Harmful</td></tr></table></div></body></html>
