<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 2. Sockets and Patterns</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="prev" href="ch01s13.html" title="Warning: Unstable Paradigms!" /><link rel="next" href="ch02s02.html" title="Messaging Patterns" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 2. Sockets and Patterns</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch01s13.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch02s02.html">Next</a></td></tr></table><hr /></div><div class="chapter" title="Chapter 2. Sockets and Patterns"><div class="titlepage"><div><div><h2 class="title"><a id="sockets-and-patterns"></a>Chapter 2. Sockets and Patterns</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="sect1"><a href="ch02.html#idp19089488">The Socket API</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch02.html#idp19096896">Plugging Sockets into the Topology</a></span></dt><dt><span class="sect2"><a href="ch02.html#idp19111568">Sending and Receiving Messages</a></span></dt><dt><span class="sect2"><a href="ch02.html#idp19117504">Unicast Transports</a></span></dt><dt><span class="sect2"><a href="ch02.html#idp19125480">ØMQ is Not a Neutral Carrier</a></span></dt><dt><span class="sect2"><a href="ch02.html#idp19131448">I/O Threads</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch02s02.html">Messaging Patterns</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch02s02.html#idp19144304">High-Level Messaging Patterns</a></span></dt><dt><span class="sect2"><a href="ch02s02.html#idp19147088">Working with Messages</a></span></dt><dt><span class="sect2"><a href="ch02s02.html#idp19174568">Handling Multiple Sockets</a></span></dt><dt><span class="sect2"><a href="ch02s02.html#idp19185912">Multipart Messages</a></span></dt><dt><span class="sect2"><a href="ch02s02.html#idp19194104">Intermediaries and Proxies</a></span></dt><dt><span class="sect2"><a href="ch02s02.html#idp19195912">The Dynamic Discovery Problem</a></span></dt><dt><span class="sect2"><a href="ch02s02.html#idp19205032">Shared Queue (DEALER and ROUTER sockets)</a></span></dt><dt><span class="sect2"><a href="ch02s02.html#idp19224320">ØMQ's Built-In Proxy Function</a></span></dt><dt><span class="sect2"><a href="ch02s02.html#idp19229976">Transport Bridging</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch02s03.html">Handling Errors and ETERM</a></span></dt><dt><span class="sect1"><a href="ch02s04.html">Handling Interrupt Signals</a></span></dt><dt><span class="sect1"><a href="ch02s05.html">Detecting Memory Leaks</a></span></dt><dt><span class="sect1"><a href="ch02s06.html">Multithreading with ØMQ</a></span></dt><dt><span class="sect1"><a href="ch02s07.html">Signaling Between Threads (PAIR Sockets)</a></span></dt><dt><span class="sect1"><a href="ch02s08.html">Node Coordination</a></span></dt><dt><span class="sect1"><a href="ch02s09.html">Zero-Copy</a></span></dt><dt><span class="sect1"><a href="ch02s10.html">Pub-Sub Message Envelopes</a></span></dt><dt><span class="sect1"><a href="ch02s11.html">High-Water Marks</a></span></dt><dt><span class="sect1"><a href="ch02s12.html">Missing Message Problem Solver</a></span></dt></dl></div><p>In ØMQ基础<a class="xref" href="ch01.html" title="Chapter 1. ØMQ基础">Chapter 1, <em>ØMQ基础</em></a> we took ØMQ for a drive, with some basic examples of the main ØMQ patterns: request-reply, pub-sub, and pipeline. In this chapter, we're going to get our hands dirty and start to learn how to use these tools in real programs.</p><p>We'll cover:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>How to create and work with ØMQ sockets.</p></li><li class="listitem"><p>How to send and receive messages on sockets.</p></li><li class="listitem"><p>How to build your apps around ØMQ's asynchronous I/O model.</p></li><li class="listitem"><p>How to handle multiple sockets in one thread.</p></li><li class="listitem"><p>How to handle fatal and nonfatal errors properly.</p></li><li class="listitem"><p>How to handle interrupt signals like Ctrl-C.</p></li><li class="listitem"><p>How to shut down a ØMQ application cleanly.</p></li><li class="listitem"><p>How to check a ØMQ application for memory leaks.</p></li><li class="listitem"><p>How to send and receive multipart messages.</p></li><li class="listitem"><p>How to forward messages across networks.</p></li><li class="listitem"><p>How to build a simple message queuing broker.</p></li><li class="listitem"><p>How to write multithreaded applications with ØMQ.</p></li><li class="listitem"><p>How to use ØMQ to signal between threads.</p></li><li class="listitem"><p>How to use ØMQ to coordinate a network of nodes.</p></li><li class="listitem"><p>How to create and use message envelopes for pub-sub.</p></li><li class="listitem"><p>Using the HWM (high-water mark) to protect against memory overflows.</p></li></ul></div><div class="sect1" title="The Socket API"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp19089488"></a>The Socket API</h2></div></div></div><p>To be perfectly honest, ØMQ does a kind of switch-and-bait on you, for which we don't apologize. It's for your own good and it hurts us more than it hurts you. ØMQ presents a familiar socket-based API, which requires great effort for us to hide a bunch of message-processing engines. However, the result will slowly fix your world view about how to design and write distributed software.</p><p>Sockets are the de facto standard API for network programming, as well as being useful for stopping your eyes from falling onto your cheeks. One thing that makes ØMQ especially tasty to developers is that it uses sockets and messages instead of some other arbitrary set of concepts. Kudos to Martin Sustrik for pulling this off. It turns "Message Oriented Middleware", a phrase guaranteed to send the whole room off to Catatonia, into "Extra Spicy Sockets!", which leaves us with a strange craving for pizza and a desire to know more.</p><p>Like a favorite dish, ØMQ sockets are easy to digest. Sockets have a life in four parts, just like BSD sockets:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Creating and destroying sockets, which go together to form a karmic circle of socket life (see <code class="literal">zmq_socket()</code>, <code class="literal">zmq_close()</code>).</p></li><li class="listitem"><p>Configuring sockets by setting options on them and checking them if necessary (see <code class="literal">zmq_setsockopt()</code>, <code class="literal">zmq_getsockopt()</code>).</p></li><li class="listitem"><p>Plugging sockets into the network topology by creating ØMQ connections to and from them (see <code class="literal">zmq_bind()</code>, <code class="literal">zmq_connect()</code>).</p></li><li class="listitem"><p>Using the sockets to carry data by writing and receiving messages on them (see <code class="literal">zmq_send()</code>, <code class="literal">zmq_recv()</code>).</p></li></ul></div><p>Note that sockets are always void pointers, and messages (which we'll come to very soon) are structures. So in C you pass sockets as-such, but you pass addresses of messages in all functions that work with messages, like <code class="literal">zmq_send()</code> and <code class="literal">zmq_recv()</code>. As a mnemonic, realize that "in ØMQ, all your sockets are belong to us", but messages are things you actually own in your code.</p><p>Creating, destroying, and configuring sockets works as you'd expect for any object. But remember that ØMQ is an asynchronous, elastic fabric. This has some impact on how we plug sockets into the network topology and how we use the sockets after that.</p><div class="sect2" title="Plugging Sockets into the Topology"><div class="titlepage"><div><div><h3 class="title"><a id="idp19096896"></a>Plugging Sockets into the Topology</h3></div></div></div><p>To create a connection between two nodes, you use <code class="literal">zmq_bind()</code> in one node and <code class="literal">zmq_connect()</code> in the other.  As a general rule of thumb, the node that does <code class="literal">zmq_bind()</code> is a "server", sitting on a well-known network address, and the node which does <code class="literal">zmq_connect()</code> is a "client", with unknown or arbitrary network addresses. Thus we say that we "bind a socket to an endpoint" and "connect a socket to an endpoint", the endpoint being that well-known network address.</p><p>ØMQ connections are somewhat different from classic TCP connections. The main notable differences are:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>They go across an arbitrary transport (<code class="literal">inproc</code>, <code class="literal">ipc</code>, <code class="literal">tcp</code>, <code class="literal">pgm</code>, or <code class="literal">epgm</code>). See <code class="literal">zmq_inproc()</code>, <code class="literal">zmq_ipc()</code>, <code class="literal">zmq_tcp()</code>, <code class="literal">zmq_pgm()</code>, and <code class="literal">zmq_epgm()</code>.</p></li><li class="listitem"><p>One socket may have many outgoing and many incoming connections.</p></li><li class="listitem"><p>There is no <code class="literal">zmq_accept</code>() method. When a socket is bound to an endpoint it automatically starts accepting connections.</p></li><li class="listitem"><p>The network connection itself happens in the background, and ØMQ will automatically reconnect if the network connection is broken (e.g., if the peer disappears and then comes back).</p></li><li class="listitem"><p>Your application code cannot work with these connections directly; they are encapsulated under the socket.</p></li></ul></div><p>Many architectures follow some kind of client/server model, where the server is the component that is most static, and the clients are the components that are most dynamic, i.e., they come and go the most. There are sometimes issues of addressing: servers will be visible to clients, but not necessarily vice versa. So mostly it's obvious which node should be doing <code class="literal">zmq_bind()</code> (the server) and which should be doing <code class="literal">zmq_connect()</code> (the client). It also depends on the kind of sockets you're using, with some exceptions for unusual network architectures. We'll look at socket types later.</p><p>Now, imagine we start the client <span class="emphasis"><em>before</em></span> we start the server. In traditional networking, we get a big red Fail flag. But ØMQ lets us start and stop pieces arbitrarily. As soon as the client node does <code class="literal">zmq_connect()</code>, the connection exists and that node can start to write messages to the socket. At some stage (hopefully before messages queue up so much that they start to get discarded, or the client blocks), the server comes alive, does a <code class="literal">zmq_bind()</code>, and ØMQ starts to deliver messages.</p><p>A server node can bind to many endpoints (that is, a combination of protocol and address) and it can do this using a single socket. This means it will accept connections across different transports:</p><pre class="programlisting">
zmq_bind (socket, "tcp://*:5555");
zmq_bind (socket, "tcp://*:9999");
zmq_bind (socket, "inproc://somename");
</pre><p>With most transports, you cannot bind to the same endpoint twice, unlike for example in UDP. The <code class="literal">ipc</code> transport does, however, let one process bind to an endpoint already used by a first process. It's meant to allow a process to recover after a crash.</p><p>Although ØMQ tries to be neutral about which side binds and which side connects, there are differences. We'll see these in more detail later. The upshot is that you should usually think in terms of "servers" as static parts of your topology that bind to more or less fixed endpoints, and "clients" as dynamic parts that come and go and connect to these endpoints. Then, design your application around this model. The chances that it will "just work" are much better like that.</p><p>Sockets have types. The socket type defines the semantics of the socket, its policies for routing messages inwards and outwards, queuing, etc. You can connect certain types of socket together, e.g., a publisher socket and a subscriber socket. Sockets work together in "messaging patterns". We'll look at this in more detail later.</p><p>It's the ability to connect sockets in these different ways that gives ØMQ its basic power as a message queuing system. There are layers on top of this, such as proxies, which we'll get to later. But essentially, with ØMQ you define your network architecture by plugging pieces together like a child's construction toy.</p></div><div class="sect2" title="Sending and Receiving Messages"><div class="titlepage"><div><div><h3 class="title"><a id="idp19111568"></a>Sending and Receiving Messages</h3></div></div></div><p>To send and receive messages you use the <code class="literal">zmq_msg_send()</code> and <code class="literal">zmq_msg_recv()</code> methods. The names are conventional, but ØMQ's I/O model is different enough from the classic TCP model<a class="xref" href="ch02.html#figure-9" title="Figure 2.1. TCP sockets are 1 to 1">Figure 2.1, “TCP sockets are 1 to 1”</a> that you will need time to get your head around it.</p><div class="figure"><a id="figure-9"></a><p class="title"><strong>Figure 2.1. TCP sockets are 1 to 1</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/fig9.png" alt="TCP sockets are 1 to 1" /></div></div></div><br class="figure-break" /><p>Let's look at the main differences between TCP sockets and ØMQ sockets when it comes to working with data:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>ØMQ sockets carry messages, like UDP, rather than a stream of bytes as TCP does. A ØMQ message is length-specified binary data. We'll come to messages shortly; their design is optimized for performance and so a little tricky.</p></li><li class="listitem"><p>ØMQ sockets do their I/O in a background thread. This means that messages arrive in local input queues and are sent from local output queues, no matter what your application is busy doing.</p></li><li class="listitem"><p>ØMQ sockets have one-to-N routing behavior built-in, according to the socket type.</p></li></ul></div><p>The <code class="literal">zmq_send()</code> method does not actually send the message to the socket connection(s). It queues the message so that the I/O thread can send it asynchronously. It does not block except in some exception cases. So the message is not necessarily sent when <code class="literal">zmq_send()</code> returns to your application.</p></div><div class="sect2" title="Unicast Transports"><div class="titlepage"><div><div><h3 class="title"><a id="idp19117504"></a>Unicast Transports</h3></div></div></div><p>ØMQ provides a set of unicast transports (<code class="literal">inproc</code>, <code class="literal">ipc</code>, and <code class="literal">tcp</code>) and multicast transports (epgm, pgm). Multicast is an advanced technique that we'll come to later. Don't even start using it unless you know that your fan-out ratios will make 1-to-N unicast impossible.</p><p>For most common cases, use <span class="bold"><strong><code class="literal">tcp</code></strong></span>, which is a <span class="emphasis"><em>disconnected TCP</em></span> transport. It is elastic, portable, and fast enough for most cases. We call this disconnected because ØMQ's <code class="literal">tcp</code> transport doesn't require that the endpoint exists before you connect to it. Clients and servers can connect and bind at any time, can go and come back, and it remains transparent to applications.</p><p>The inter-process <code class="literal">ipc</code> transport is disconnected, like <code class="literal">tcp</code>. It has one limitation: it does not yet work on Windows. By convention we use endpoint names with an ".ipc" extension to avoid potential conflict with other file names. On UNIX systems, if you use <code class="literal">ipc</code> endpoints you need to create these with appropriate permissions otherwise they may not be shareable between processes running under different user IDs. You must also make sure all processes can access the files, e.g., by running in the same working directory.</p><p>The inter-thread transport, <span class="bold"><strong><code class="literal">inproc</code></strong></span>, is a connected signaling transport. It is much faster than <code class="literal">tcp</code> or <code class="literal">ipc</code>. This transport has a specific limitation compared to <code class="literal">tpc</code> and <code class="literal">icp</code>: <span class="bold"><strong>the server must issue a bind before any client issues a connect</strong></span>. This is something future versions of ØMQ may fix, but at present this defines how you use <code class="literal">inproc</code> sockets. We create and bind one socket and start the child threads, which create and connect the other sockets.</p></div><div class="sect2" title="ØMQ is Not a Neutral Carrier"><div class="titlepage"><div><div><h3 class="title"><a id="idp19125480"></a>ØMQ is Not a Neutral Carrier</h3></div></div></div><p>A common question that newcomers to ØMQ ask (it's one I've asked myself) is, "how do I write an XYZ server in ØMQ?" For example, "how do I write an HTTP server in ØMQ?" The implication is that if we use normal sockets to carry HTTP requests and responses, we should be able to use ØMQ sockets to do the same, only much faster and better.</p><p>The answer used to be "this is not how it works". ØMQ is not a neutral carrier: it imposes a framing on the transport protocols it uses. This framing is not compatible with existing protocols, which tend to use their own framing. For example, compare an HTTP request and a ØMQ request, both over TCP/IP.</p><div class="figure"><a id="figure-10"></a><p class="title"><strong>Figure 2.2. HTTP on the Wire</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/fig10.png" alt="HTTP on the Wire" /></div></div></div><br class="figure-break" /><p>The HTTP request uses CR-LF as its simplest framing delimiter<a class="xref" href="ch02.html#figure-11" title="Figure 2.3. ØMQ on the Wire">Figure 2.3, “ØMQ on the Wire”</a>, whereas ØMQ uses a length-specified frame<a class="xref" href="ch02.html#figure-11" title="Figure 2.3. ØMQ on the Wire">Figure 2.3, “ØMQ on the Wire”</a>. So you could write an HTTP-like protocol using ØMQ, using for example the request-reply socket pattern. But it would not be HTTP.</p><div class="figure"><a id="figure-11"></a><p class="title"><strong>Figure 2.3. ØMQ on the Wire</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/fig11.png" alt="ØMQ on the Wire" /></div></div></div><br class="figure-break" /><p>Since v3.3, however, ØMQ has a socket option called <code class="literal">ZMQ_ROUTER_RAW</code> that lets you read and write data without the ØMQ framing. You could use this to read and write proper HTTP requests and responses. Hardeep Singh contributed this change so that he could connect to Telnet servers from his ØMQ application. At time of writing this is still somewhat experimental, but it shows how ØMQ keeps evolving to solve new problems. Maybe the next patch will be yours.</p></div><div class="sect2" title="I/O Threads"><div class="titlepage"><div><div><h3 class="title"><a id="idp19131448"></a>I/O Threads</h3></div></div></div><p>We said that ØMQ does I/O in a background thread. One I/O thread (for all sockets) is sufficient for all but the most extreme applications. When you create a new context, it starts with one I/O thread. The general rule of thumb is to allow one I/O thread per gigabyte of data in or out per second. To raise the number of I/O threads, use the <code class="literal">zmq_ctx_set()</code> call <span class="emphasis"><em>before</em></span> creating any sockets:</p><pre class="programlisting">
int io_threads = 4;
void *context = zmq_ctx_new ();
zmq_ctx_set (context, ZMQ_IO_THREADS, io_threads);
assert (zmq_ctx_get (context, ZMQ_IO_THREADS) == io_threads);
</pre><p>We've seen that one socket can handle dozens, even thousands of connections at once. This has a fundamental impact on how you write applications. A traditional networked application has one process or one thread per remote connection, and that process or thread handles one socket. ØMQ lets you collapse this entire structure into a single process and then break it up as necessary for scaling.</p><p>If you are using ØMQ for inter-thread communications only (i.e., a multithreaded application that does no external socket I/O) you can set the I/O threads to zero. It's not a significant optimization though, more of a curiosity.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch01s13.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch02s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Warning: Unstable Paradigms! </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Messaging Patterns</td></tr></table></div></body></html>
