<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Group Messaging</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="ch08.html" title="Chapter 8. A Framework for Distributed Computing" /><link rel="prev" href="ch08s05.html" title="Point-to-Point Messaging" /><link rel="next" href="ch08s07.html" title="Testing and Simulation" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Group Messaging</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch08s05.html">Prev</a> </td><th width="60%" align="center">Chapter 8. A Framework for Distributed Computing</th><td width="20%" align="right"> <a accesskey="n" href="ch08s07.html">Next</a></td></tr></table><hr /></div><div class="sect1" title="Group Messaging"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp21350648"></a>Group Messaging</h2></div></div></div><p>Group messaging is a common and very useful pattern. The concept is simple: instead of talking to a single node, you talk to a "group" of nodes. The group is just a name, a string that you agree on in the application. It's precisely like using the pub-sub prefixes in PUB and SUB sockets. In fact, the only reason I say "group messaging" and not "pub-sub" is to prevent confusion, because we're not going to use PUB-SUB sockets for this.</p><p>PUB-SUB sockets would almost work. But we've just done such a lot of work to solve the late joiner problem. Applications are inevitably going to wait for peers to arrive before sending messages to groups, so we have to build on the Harmony pattern rather than start again beside it.</p><p>Let's look at the operations we want to do on groups:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>We want to join and leave groups.</p></li><li class="listitem"><p>We want to know what other nodes are in any given group.</p></li><li class="listitem"><p>We want to send a message to (all nodes in) a group.</p></li></ul></div><p>These look familiar to anyone who's used Internet Relay Chat, except that we have no server. Every node will need to keep track of what each group represents. This information will not always be fully consistent across the network, but it will be close enough.</p><p>Our interface will track a set of groups (each an object). These are all the known groups with one or more member node, excluding ourselves. We'll track nodes as they leave and join groups. Because nodes can join the network at any time, we have to tell new peers what groups we're in. When a peer disappears, we'll remove it from all groups we know about.</p><p>This gives us some new protocol commands:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="literal">JOIN</code> - we send this to all peers when we join a group.</p></li><li class="listitem"><p><code class="literal">LEAVE</code> - we send this to all peers when we leave a group.</p></li></ul></div><p>Plus, we add a <code class="literal">groups</code> field to the first command we send (renamed from <code class="literal">OHAI</code> to <code class="literal">HELLO</code> at this point because I need a larger lexicon of command verbs).</p><p>Lastly, let's add a way for peers to double-check the accuracy of their group data. The risk is that we miss one of the above messages. Though we are using Harmony to avoid the typical message loss at startup, it's worth being paranoid. For now, all we need is a way to detect such a failure. We'll deal with recovery later, if the problem actually happens.</p><p>I'll use the UDP beacon for this. What we want is a rolling counter that simply tells how many join and leave operations ("transitions") there have been for a node. It starts at 0 and increments for each group we join or leave. We can use a minimal 1-byte value because that will catch all failures except the astronomically rare "we lost precisely 256 messages in a row" failure (this is the one that hits during the first demo). We will also put the transitions counter into the <code class="literal">JOIN</code>, <code class="literal">LEAVE</code>, and <code class="literal">HELLO</code> commands. And to try to provoke the problem, we'll test by joining/leaving several hundred groups with a high-water mark set to 10 or so.</p><p>It's time to choose verbs for the group messaging. We need a command that means "talk to one peer" and one that means "talk to many peers". After some attempts, my best choices are <code class="literal">WHISPER</code> and <code class="literal">SHOUT</code>, and this is what the code uses. The <code class="literal">SHOUT</code> command needs to tell the user the group name, as well as the sender peer.</p><p>Because groups are like pub-sub, you might be tempted to use this to broadcast the <code class="literal">JOIN</code> and <code class="literal">LEAVE</code> commands as well, perhaps by creating a "global" group that all nodes join. My advice is to keep groups purely as user-space concepts for two reasons. First, how do you join the global group if you need the global group to send out a <code class="literal">JOIN</code> command? Second, it creates special cases (reserved names) which are messy.</p><p>It's simpler just to send <code class="literal">JOIN</code>s and <code class="literal">LEAVE</code>s explicitly to all connected peers, period.</p><p>I'm not going to work through the implementation of group messaging in detail because it's fairly pedantic and not too exciting. The data structures for group and peer management aren't optimal, but they're workable. We use the following:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>A list of groups for our interface, which we can send to new peers in a <code class="literal">HELLO</code> command;</p></li><li class="listitem"><p>A hash of groups for other peers, which we update with information from <code class="literal">HELLO</code>, <code class="literal">JOIN</code>, and <code class="literal">LEAVE</code> commands;</p></li><li class="listitem"><p>A hash of peers for each group, which we update with the same three commands.</p></li></ul></div><p>At this stage, I'm starting to get pretty happy with the binary serialization (our codec generator from Advanced Architecture using ØMQ<a class="xref" href="ch07.html" title="Chapter 7. Advanced Architecture using ØMQ">Chapter 7, <em>Advanced Architecture using ØMQ</em></a>), which handles lists and dictionaries as well as strings and integers.</p><p>This version is tagged in the repository as v0.2.0 and you can <a class="ulink" href="https://github.com/zeromq/zyre/tags" target="_top">download the tarball</a> if you want to check what the code looked like at this stage.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch08s05.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch08.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch08s07.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Point-to-Point Messaging </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Testing and Simulation</td></tr></table></div></body></html>
