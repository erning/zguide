<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Missing Message Problem Solver</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="ch02.html" title="Chapter 2. Sockets and Patterns" /><link rel="prev" href="ch02s11.html" title="High-Water Marks" /><link rel="next" href="ch03.html" title="Chapter 3. Advanced Request-Reply Patterns" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Missing Message Problem Solver</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch02s11.html">Prev</a> </td><th width="60%" align="center">Chapter 2. Sockets and Patterns</th><td width="20%" align="right"> <a accesskey="n" href="ch03.html">Next</a></td></tr></table><hr /></div><div class="sect1" title="Missing Message Problem Solver"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp19350472"></a>Missing Message Problem Solver</h2></div></div></div><p>As you build applications with ØMQ, you will come across this problem more than once: losing messages that you expect to receive. We have put together a diagram<a class="xref" href="ch02s12.html#figure-25" title="Figure 2.17. Missing Message Problem Solver">Figure 2.17, “Missing Message Problem Solver”</a> that walks through the most common causes for this.</p><div class="figure"><a id="figure-25"></a><p class="title"><strong>Figure 2.17. Missing Message Problem Solver</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/fig25.png" alt="Missing Message Problem Solver" /></div></div></div><br class="figure-break" /><p>Here's a summary of what the graphic says:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>On SUB sockets, set a subscription using <code class="literal">zmq_setsockopt()</code> with <code class="literal">ZMQ_SUBSCRIBE</code>, or you won't get messages. Because you subscribe to messages by prefix, if you subscribe to "" (an empty subscription), you will get everything.</p></li><li class="listitem"><p>If you start the SUB socket (i.e., establish a connection to a PUB socket) <span class="emphasis"><em>after</em></span> the PUB socket has started sending out data, you will lose whatever it published before the connection was made. If this is a problem, set up your architecture so the SUB socket starts first, then the PUB socket starts publishing.</p></li><li class="listitem"><p>Even if you synchronize a SUB and PUB socket, you may still lose messages. It's due to the fact that internal queues aren't created until a connection is actually created. If you can switch the bind/connect direction so the SUB socket binds, and the PUB socket connects, you may find it works more as you'd expect.</p></li><li class="listitem"><p>If you're using REP and REQ sockets, and you're not sticking to the synchronous send/recv/send/recv order, ØMQ will report errors, which you might ignore. Then, it would look like you're losing messages. If you use REQ or REP, stick to the send/recv order, and always, in real code, check for errors on ØMQ calls.</p></li><li class="listitem"><p>If you're using PUSH sockets, you'll find that the first PULL socket to connect will grab an unfair share of messages. The accurate rotation of messages only happens when all PULL sockets are successfully connected, which can take some milliseconds. As an alternative to PUSH/PULL, for lower data rates, consider using ROUTER/DEALER and the load balancing pattern.</p></li><li class="listitem"><p>If you're sharing sockets across threads, don't. It will lead to random weirdness, and crashes.</p></li><li class="listitem"><p>If you're using <code class="literal">inproc</code>, make sure both sockets are in the same context. Otherwise the connecting side will in fact fail. Also, bind first, then connect. <code class="literal">inproc</code> is not a disconnected transport like <code class="literal">tcp</code>.</p></li><li class="listitem"><p>If you're using ROUTER sockets, it's remarkably easy to lose messages by accident, by sending malformed identity frames (or forgetting to send an identity frame). In general setting the <code class="literal">ZMQ_ROUTER_MANDATORY</code> option on ROUTER sockets is a good idea, but do also check the return code on every send call.</p></li><li class="listitem"><p>Lastly, if you really can't figure out what's going wrong, make a <span class="emphasis"><em>minimal</em></span> test case that reproduces the problem, and ask for help from the ØMQ community.</p></li></ul></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch02s11.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch02.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">High-Water Marks </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 3. Advanced Request-Reply Patterns</td></tr></table></div></body></html>
