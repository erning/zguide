<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Unprotocols</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="ch07.html" title="Chapter 7. Advanced Architecture using ØMQ" /><link rel="prev" href="ch07.html" title="Chapter 7. Advanced Architecture using ØMQ" /><link rel="next" href="ch07s03.html" title="Serializing Your Data" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Unprotocols</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch07.html">Prev</a> </td><th width="60%" align="center">Chapter 7. Advanced Architecture using ØMQ</th><td width="20%" align="right"> <a accesskey="n" href="ch07s03.html">Next</a></td></tr></table><hr /></div><div class="sect1" title="Unprotocols"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp20848408"></a>Unprotocols</h2></div></div></div><div class="sect2" title="Protocols Without The Goats"><div class="titlepage"><div><div><h3 class="title"><a id="idp20848728"></a>Protocols Without The Goats</h3></div></div></div><p>When this man thinks of protocols, this man thinks of massive documents written by committees, over years. This man thinks of the IETF, W3C, ISO, Oasis, regulatory capture, FRAND patent license disputes, and soon after, this man thinks of retirement to a nice little farm in northern Bolivia up in the mountains where the only other needlessly stubborn beings are the goats chewing up the coffee plants.</p><p>Now, I've nothing personal against committees. The useless folk need a place to sit out their lives with minimal risk of reproducing; after all, that only seems fair. But most committee protocols tend towards complexity (the ones that work), or trash (the ones we don't talk about). There's a few reasons for this. One is the amount of money at stake. More money means more people who want their particular prejudices and assumptions expressed in prose. But two is the lack of good abstractions on which to build. People have tried to build reusable protocol abstractions, like BEEP. Most did not stick, and those that did, like SOAP and XMPP, are on the complex side of things.</p><p>It used to be, decades ago, when the Internet was a young modest thing, that protocols were short and sweet. They weren't even "standards", but "requests for comments", which is as modest as you can get. It's been one of my goals since we started iMatix in 1995 to find a way for ordinary people like me to write small, accurate protocols without the overhead of the committees.</p><p>Now, ØMQ does appear to provide a living, successful protocol abstraction layer with its "we'll carry multipart messages over random transports" way of working. Because ØMQ deals silently with framing, connections, and routing, it's surprisingly easy to write full protocol specs on top of ØMQ, and in Reliable Request-Reply Patterns<a class="xref" href="ch04.html" title="Chapter 4. Reliable Request-Reply Patterns">Chapter 4, <em>Reliable Request-Reply Patterns</em></a> and Advanced Pub-Sub Patterns<a class="xref" href="ch05.html" title="Chapter 5. Advanced Pub-Sub Patterns">Chapter 5, <em>Advanced Pub-Sub Patterns</em></a> I showed how to do this.</p><p>Somewhere around mid-2007, I kicked off the Digital Standards Organization to define new simpler ways of producing little standards, protocols, and specifications. In my defense, it was a quiet summer. At the time, I wrote that a new specification should take <a class="ulink" href="http://www.digistan.org/spec:1" target="_top">"minutes to explain, hours to design, days to write, weeks to prove, months to become mature, and years to replace."</a></p><p>In 2010, we started calling such little specifications <span class="emphasis"><em>unprotocols</em></span>, which some people might mistake for a dastardly plan for world domination by a shadowy international organization, but which really just means "protocols without the goats".</p></div><div class="sect2" title="Contracts Are Hard"><div class="titlepage"><div><div><h3 class="title"><a id="idp20853752"></a>Contracts Are Hard</h3></div></div></div><p>Writing contracts is perhaps the most difficult part of large-scale architecture. With unprotocols, we remove as much of the unnecessary friction as possible. What remains is still a hard set of problems to solve. A good contract (be it an API, a protocol, or a rental agreement) has to be simple, unambiguous, technically sound, and easy to enforce.</p><p>Like any technical skill, it's something you have to learn and practice. There are a series of specifications on the</p><p><a class="ulink" href="http://rfc.zeromq.org" target="_top">ØMQ RFC site</a>, which are worth reading and using them as a basis for your own specifications when you find yourself in need.</p><p>I'll try to summarize my experience as a protocol writer:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Start simple, and develop your specifications step-by-step. Don't solve problems you don't have in front of you.</p></li><li class="listitem"><p>Use very clear and consistent language. A protocol may often break down into commands and fields; use clear short names for these entities.</p></li><li class="listitem"><p>Try to avoid inventing concepts. Reuse anything you can from existing specifications. Use terminology that is obvious and clear to your audience.</p></li><li class="listitem"><p>Make <span class="emphasis"><em>nothing</em></span> for which you cannot demonstrate an immediate need. Your specification solves problems; it does not provide features. Make the simplest plausible solution for each problem that you identify.</p></li><li class="listitem"><p>Implement your protocol <span class="emphasis"><em>as you build it</em></span>, so that you are aware of the technical consequences of each choice. Use a language that makes it hard (like C) and not one that makes it easy (like Python).</p></li><li class="listitem"><p>Test your specification <span class="emphasis"><em>as you build it</em></span> on other people. Your best feedback on a specification is when someone else tries to implement it without the assumptions and knowledge that you have in your head.</p></li><li class="listitem"><p>Cross-test rapidly and consistently, throwing others' clients against your servers and vice versa.</p></li><li class="listitem"><p>Be prepared to throw it out and start again as often as needed. Plan for this, by layering your architecture so that e.g., you can keep an API but change the underlying protocols.</p></li><li class="listitem"><p>Only use constructs that are independent of programming language and operating system.</p></li><li class="listitem"><p>Solve a large problem in layers, making each layer an independent specification. Beware of creating monolithic protocols. Think about how reusable each layer is. Think about how different teams could build competing specifications at each layer.</p></li></ul></div><p>And above all, <span class="emphasis"><em>write it down</em></span>. Code is not a specification. The point about a written specification is that no matter how weak it is, it can be systematically improved. By writing down a specification, you will also spot inconsistencies and gray areas that are impossible to see in code.</p><p>If this sounds hard, don't worry too much. One of the less obvious benefits of using ØMQ is that it cuts the effort necessary to write a protocol spec by perhaps 90% or more because it already handles framing, routing, queuing, and so on. This means that you can experiment rapidly, make mistakes cheaply, and thus learn rapidly.</p></div><div class="sect2" title="How to Write Unprotocols"><div class="titlepage"><div><div><h3 class="title"><a id="idp20861960"></a>How to Write Unprotocols</h3></div></div></div><p>When you start to write an unprotocol specification document, stick to a consistent structure so that your readers know what to expect. Here is the structure I use:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Cover section: with a 1-line summary, URL to the spec, formal name, version, who to blame.</p></li><li class="listitem"><p>License for the text: absolutely needed for public specifications.</p></li><li class="listitem"><p>The change process: i.e., how can I as a reader fix problems in the specification?</p></li><li class="listitem"><p>Use of language: MUST, MAY, SHOULD, and so on, with a reference to RFC 2119.</p></li><li class="listitem"><p>Maturity indicator: is this an experimental, draft, stable, legacy, or retired?</p></li><li class="listitem"><p>Goals of the protocol: what problems is it trying to solve?</p></li><li class="listitem"><p>Formal grammar: prevents arguments due to different interpretations of the text.</p></li><li class="listitem"><p>Technical explanation: semantics of each message, error handling, and so on.</p></li><li class="listitem"><p>Security discussion: explicitly, how secure the protocol is.</p></li><li class="listitem"><p>References: to other documents, protocols, and so on.</p></li></ul></div><p>Writing clear, expressive text is hard. Do avoid trying to describe implementations of the protocol. Remember that you're writing a contract. You describe in clear language the obligations and expectations of each party, the level of obligation, and the penalties for breaking the rules. You do not try to define <span class="emphasis"><em>how</em></span> each party honors its part of the deal.</p><p>Here are some key points about unprotocols:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>As long as your process is open, then you don't need a committee: just make clean minimal designs and make sure anyone is free to improve them.</p></li><li class="listitem"><p>If use an existing license, then you don't have legal worries afterwards. I use GPLv3 for my public specifications and advise you to do the same. For in-house work, standard copyright is perfect.</p></li><li class="listitem"><p>Formality is valuable. That is, learn to write a formal grammar such as ABNF (Augmented Backus-Naur Form) and use this to fully document your messages.</p></li><li class="listitem"><p>Use a market-driven life cycle process like <a class="ulink" href="http://www.digistan.org/spec:1" target="_top">Digistan's COSS</a> so that people place the right weight on your specs as they mature (or don't).</p></li></ul></div></div><div class="sect2" title="Why use the GPLv3 for Public Specifications?"><div class="titlepage"><div><div><h3 class="title"><a id="idp20869488"></a>Why use the GPLv3 for Public Specifications?</h3></div></div></div><p>The license you choose is particularly crucial for public specifications. Traditionally, protocols are published under custom licenses, where the authors own the text and derived works are forbidden. This sounds great (after all, who wants to see a protocol forked?), but it's in fact highly risky. A protocol committee is vulnerable to capture, and if the protocol is important and valuable, the incentive for capture grows.</p><p>Once captured, like some wild animals, an important protocol will often die. The real problem is that there's no way to <span class="emphasis"><em>free</em></span> a captive protocol published under a conventional license. The word "free" isn't just an adjective to describe speech or air, it's also a verb, and the right to fork a work <span class="emphasis"><em>against the wishes of the owner</em></span> is essential to avoiding capture.</p><p>Let me explain this in shorter words. Imagine that iMatix writes a protocol today that's really amazing and popular. We publish the spec and many people implement it. Those implementations are fast and awesome, and free as in beer. They start to threaten an existing business. Their expensive commercial product is slower and can't compete. So one day they come to our iMatix office in Maetang-Dong, South Korea, and offer to buy our firm. Because we're spending vast amounts on sushi and beer, we accept gratefully. With evil laughter, the new owners of the protocol stop improving the public version, close the specification, and add patented extensions. Their new products support this new protocol version, but the open source versions are legally blocked from doing so. The company takes over the whole market, and competition ends.</p><p>When you contribute to an open source project, you really want to know your hard work won't be used against you by a closed source competitor. This is why the GPL beats the "more permissive" BSD/MIT/X11 licenses for most contributors. These licenses give permission to cheat. This applies just as much to protocols as to source code.</p><p>When you implement a GPLv3 specification, your applications are of course yours, and licensed any way you like. But you can be certain of two things. One, that specification will <span class="emphasis"><em>never</em></span> be embraced and extended into proprietary forms. Any derived forms of the specification must also be GPLv3. Two, no one who ever implements or uses the protocol will ever launch a patent attack on anything it covers, nor can they add their patented technology to it without granting the world a free license.</p></div><div class="sect2" title="Using ABNF"><div class="titlepage"><div><div><h3 class="title"><a id="idp20873984"></a>Using ABNF</h3></div></div></div><p>My advice when writing protocol specs is to learn and use a formal grammar. It's just less hassle than allowing others to interpret what you mean, and then recover from the inevitable false assumptions. The target of your grammar is other people, engineers, not compilers.</p><p>My favorite grammar is ABNF, as defined by <a class="ulink" href="http://www.ietf.org/rfc/rfc2234.txt" target="_top">RFC 2234</a>, because it is probably the simplest and most widely used formal language for defining bidirectional communications protocols. Most IETF (Internet Engineering Task Force) specifications use ABNF, which is good company to be in.</p><p>I'll give a 30-second crash course in writing ABNF. It may remind you of regular expressions. You write the grammar as rules. Each rule takes the form "name = elements". An element can be another rule (which you define below as another rule) or a pre-defined <span class="emphasis"><em>terminal</em></span> like <code class="literal">CRLF</code>, <code class="literal">OCTET</code>, or a number. <a class="ulink" href="http://www.ietf.org/rfc/rfc2234.txt" target="_top">The RFC</a> lists all the terminals. To define alternative elements, separate with a slash. To define repetition, use an asterisk. To group elements, use parentheses. Read the RFC because it's not intuitive.</p><p>I'm not sure if this extension is proper, but I then prefix elements with "C:" and "S:" to indicate whether they come from the client or server.</p><p>Here's a piece of ABNF for an unprotocol called NOM that we'll come back to later in this chapter:</p><pre class="screen">nom-protocol    = open-peering *use-peering

open-peering    = C:OHAI ( S:OHAI-OK / S:WTF )

use-peering     = C:ICANHAZ
                / S:CHEEZBURGER
                / C:HUGZ S:HUGZ-OK
                / S:HUGZ C:HUGZ-OK
</pre><p>I've actually used these keywords (<code class="literal">OHAI</code>, <code class="literal">WTF</code>) in commercial projects. They make developers giggly and happy. They confuse management. They're good in first drafts that you want to throw away later.</p></div><div class="sect2" title="The Cheap or Nasty Pattern"><div class="titlepage"><div><div><h3 class="title"><a id="idp20879704"></a>The Cheap or Nasty Pattern</h3></div></div></div><p>There is a general lesson I've learned over a couple of decades of writing protocols small and large. I call this the <span class="emphasis"><em>Cheap or Nasty</em></span> pattern: you can often split your work into two aspects or layers and solve these separately--one using a "cheap" approach, the other using a "nasty" approach.</p><p>The key insight to making Cheap or Nasty work is to realize that many protocols mix a low-volume chatty part for control, and a high-volume asynchronous part for data. For instance, HTTP has a chatty dialog to authenticate and get pages, and an asynchronous dialog to stream data. FTP actually splits this over two ports; one port for control and one port for data.</p><p>Protocol designers who don't separate control from data tend to make horrid protocols, because the trade-offs in the two cases are almost totally opposed. What is perfect for control is bad for data, and what's ideal for data just doesn't work for control. It's especially true when we want high performance at the same time as extensibility and good error checking.</p><p>Let's break this down using a classic client/server use case. The client connects to the server and authenticates. It then asks for some resource. The server chats back, then starts to send data back to the client. Eventually, the client disconnects or the server finishes, and the conversation is over.</p><p>Now, before starting to design these messages, stop and think, and let's compare the control dialog and the data flow:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The control dialog lasts a short time and involves very few messages. The data flow could last for hours or days, and involve billions of messages.</p></li><li class="listitem"><p>The control dialog is where all the "normal" errors happen, e.g., not authenticated, not found, payment required, censored, and so on. In contrast, any errors that happen during the data flow are exceptional (disk full, server crashed).</p></li><li class="listitem"><p>The control dialog is where things will change over time as we add more options, parameters, and so on. The data flow should barely change over time because the semantics of a resource are fairly constant over time.</p></li><li class="listitem"><p>The control dialog is essentially a synchronous request/reply dialog. The data flow is essentially a one-way asynchronous flow.</p></li></ul></div><p>These differences are critical. When we talk about performance, it applies <span class="emphasis"><em>only</em></span> to data flows. It's pathological to design a one-time control dialog to be fast. Thus when we talk about the cost of serialization, this only applies to the data flow. The cost of encoding/decoding the control flow could be huge, and for many cases it would not change a thing. So we encode control using Cheap, and we encode data flows using Nasty.</p><p>Cheap is essentially synchronous, verbose, descriptive, and flexible. A Cheap message is full of rich information that can change for each application. Your goal as designer is to make this information easy to encode and parse, trivial to extend for experimentation or growth, and highly robust against change both forwards and backwards. The Cheap part of a protocol looks like this:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>It uses a simple self-describing structured encoding for data, be it XML, JSON, HTTP-style headers, or some other. Any encoding is fine as long as there are standard simple parsers for it in your target languages.</p></li><li class="listitem"><p>It uses a straight request-reply model where each request has a success/failure reply. This makes it trivial to write correct clients and servers for a Cheap dialog.</p></li><li class="listitem"><p>It doesn't try, even marginally, to be fast. Performance doesn't matter when you do something only once or a few times per session.</p></li></ul></div><p>A Cheap parser is something you take off the shelf and throw data at. It shouldn't crash, shouldn't leak memory, should be highly tolerant, and should be relatively simple to work with. That's it.</p><p>Nasty however is essentially asynchronous, terse, silent, and inflexible. A Nasty message carries minimal information that practically never changes. Your goal as designer is to make this information ultrafast to parse, and possibly even impossible to extend and experiment with. The ideal Nasty pattern looks like this:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>It uses a hand-optimized binary layout for data, where every bit is precisely crafted.</p></li><li class="listitem"><p>It uses a pure asynchronous model where one or both peers send data without acknowledgments (or if they do, they use sneaky asynchronous techniques like credit-based flow control).</p></li><li class="listitem"><p>It doesn't try, even marginally, to be friendly. Performance is all that matters when you are doing something several million times per second.</p></li></ul></div><p>A Nasty parser is something you write by hand, which writes or reads bits, bytes, words, and integers individually and precisely. It rejects anything it doesn't like, does no memory allocations at all, and never crashes.</p><p>Cheap or Nasty isn't a universal pattern; not all protocols have this dichotomy. Also, how you use Cheap or Nasty will depend on the situation. In some cases, it can be two parts of a single protocol. In other cases, it can be two protocols, one layered on top of the other.</p></div><div class="sect2" title="Error Handling"><div class="titlepage"><div><div><h3 class="title"><a id="idp20890824"></a>Error Handling</h3></div></div></div><p>Using Cheap or Nasty makes error handling rather simpler. You have two kinds of commands and two ways to signal errors:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Synchronous control commands: errors are normal: every request has a response that is either OK or an error response.</p></li><li class="listitem"><p>Asynchronous data commands: errors are exceptional: bad commands are either discarded silently, or cause the whole connection to be closed.</p></li></ul></div><p>It's usually good to distinguish a few kinds of errors, but as always keep it minimal and add only what you need.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch07.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch07.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch07s03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 7. Advanced Architecture using ØMQ </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Serializing Your Data</td></tr></table></div></body></html>
