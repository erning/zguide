<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>使用ØMQ编程</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="ch01.html" title="Chapter 1. ØMQ基础" /><link rel="prev" href="ch01s08.html" title="分布式处理" /><link rel="next" href="ch01s10.html" title="我们为什么需要ØMQ" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">使用ØMQ编程</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch01s08.html">Prev</a> </td><th width="60%" align="center">Chapter 1. ØMQ基础</th><td width="20%" align="right"> <a accesskey="n" href="ch01s10.html">Next</a></td></tr></table><hr /></div><div class="sect1" title="使用ØMQ编程"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp19016520"></a>使用ØMQ编程</h2></div></div></div><p>看着这些示例程序后，你一定迫不及待想要用ØMQ进行编程了。不过在开始之前，我还有几条建议想给到你，这样可以省去未来的一些麻烦：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>学习ØMQ要循序渐进，虽然它只是一套API，但却提供了无尽的可能。一步一步学习它提供的功能，并完全掌握。</p></li><li class="listitem"><p>编写漂亮的代码。丑陋的代码会隐藏问题，让想要帮助你的人无从下手。比如，你会习惯于使用无意义的变量名，但读你代码的人并不知道。应使用有意义的变量名称，而不是随意起一个。代码的缩进要统一，布局清晰。漂亮的代码可以让你的世界变得更美好。</p></li><li class="listitem"><p>边写边测试，当代码出现问题，你就可以快速定位到某些行。这一点在编写ØMQ应用程序时尤为重要，因为很多时候你<span class="emphasis"><em>无法</em></span>第一次就编写出正确的代码。</p></li><li class="listitem"><p>当你发现自己编写的代码无法正常工作时，你可以将其拆分成一些代码片段，看看哪段没有正确地执行。ØMQ可以让你构建非常模块化的代码，所以应该好好利用这一点。</p></li><li class="listitem"><p>需要时应使用抽象的方法来编写程序（类、成员函数等等），不要随意拷贝代码，因为拷贝代码的同时也是在拷贝错误。</p></li></ul></div><div class="sect2" title="正确地使用上下文"><div class="titlepage"><div><div><h3 class="title"><a id="idp19021160"></a>正确地使用上下文</h3></div></div></div><p>ØMQ applications always start by creating a <span class="emphasis"><em>context</em></span>, and then using that for creating sockets. In C, it's the <code class="literal">zmq_ctx_new()</code> call. You should create and use exactly one context in your process. Technically, the context is the container for all sockets in a single process, and acts as the transport for <code class="literal">inproc</code> sockets, which are the fastest way to connect threads in one process. If at runtime a process has two contexts, these are like separate ØMQ instances. If that's explicitly what you want, OK, but otherwise remember:</p><p><span class="bold"><strong>Do one <code class="literal">zmq_ctx_new()</code> at the start of your main line code, and one <code class="literal">zmq_ctx_destroy()</code> at the end.</strong></span></p><p>If you're using the <code class="literal">fork()</code> system call, each process needs its own context. If you do <code class="literal">zmq_ctx_new()</code> in the main process before calling <code class="literal">fork()</code>, the child processes get their own contexts. In general, you want to do the interesting stuff in the child processes and just manage these from the parent process.</p></div><div class="sect2" title="正确地退出和清理"><div class="titlepage"><div><div><h3 class="title"><a id="idp19025576"></a>正确地退出和清理</h3></div></div></div><p>Classy programmers share the same motto as classy hit men: always clean-up when you finish the job. When you use ØMQ in a language like Python, stuff gets automatically freed for you. But when using C, you have to carefully free objects when you're finished with them or else you get memory leaks, unstable applications, and generally bad karma.</p><p>Memory leaks are one thing, but ØMQ is quite finicky about how you exit an application. The reasons are technical and painful, but the upshot is that if you leave any sockets open, the <code class="literal">zmq_ctx_destroy()</code> function will hang forever. And even if you close all sockets, <code class="literal">zmq_ctx_destroy()</code> will by default wait forever if there are pending connects or sends unless you set the LINGER to zero on those sockets before closing them.</p><p>The ØMQ objects we need to worry about are messages, sockets, and contexts. Luckily it's quite simple, at least in simple programs:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Use <code class="literal">zmq_send()</code> and <code class="literal">zmq_recv()</code> when you can, as it avoids the need to work with zmq_msg_t objects.</p></li><li class="listitem"><p>If you do use <code class="literal">zmq_msg_recv()</code>, always release the received message as soon as you're done with it, by calling <code class="literal">zmq_msg_close()</code>.</p></li><li class="listitem"><p>If you are opening and closing a lot of sockets, that's probably a sign that you need to redesign your application. In some cases socket handles won't be freed until you destroy the context.</p></li><li class="listitem"><p>When you exit the program, close your sockets and then call <code class="literal">zmq_ctx_destroy()</code>. This destroys the context.</p></li></ul></div><p>This is at least the case for C development. In a language with automatic object destruction, sockets and contexts will be destroyed as you leave the scope. If you use exceptions you'll have to do the clean-up in something like a "final" block, the same as for any resource.</p><p>If you're doing multithreaded work, it gets rather more complex than this. We'll get to multithreading in the next chapter, but because some of you will, despite warnings, try to run before you can safely walk, below is the quick and dirty guide to making a clean exit in a <span class="emphasis"><em>multithreaded</em></span> ØMQ application.</p><p>First, do not try to use the same socket from multiple threads. Please don't explain why you think this would be excellent fun, just please don't do it. Next, you need to shut down each socket that has ongoing requests. The proper way is to set a low LINGER value (1 second), and then close the socket. If your language binding doesn't do this for you automatically when you destroy a context, I'd suggest sending a patch.</p><p>Finally, destroy the context. This will cause any blocking receives or polls or sends in attached threads (i.e., which share the same context) to return with an error. Catch that error, and then set linger on, and close sockets in <span class="emphasis"><em>that</em></span> thread, and exit. Do not destroy the same context twice. The <code class="literal">zmq_ctx_destroy</code> in the main thread will block until all sockets it knows about are safely closed.</p><p>Voila! It's complex and painful enough that any language binding author worth his or her salt will do this automatically and make the socket closing dance unnecessary.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch01s08.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch01.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch01s10.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">分布式处理 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 我们为什么需要ØMQ</td></tr></table></div></body></html>
