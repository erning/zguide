<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Heartbeating</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="ch04.html" title="Chapter 4. Reliable Request-Reply Patterns" /><link rel="prev" href="ch04s05.html" title="Robust Reliable Queuing (Paranoid Pirate Pattern)" /><link rel="next" href="ch04s07.html" title="Contracts and Protocols" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Heartbeating</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04s05.html">Prev</a> </td><th width="60%" align="center">Chapter 4. Reliable Request-Reply Patterns</th><td width="20%" align="right"> <a accesskey="n" href="ch04s07.html">Next</a></td></tr></table><hr /></div><div class="sect1" title="Heartbeating"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp19762720"></a>Heartbeating</h2></div></div></div><p>Heartbeating solves the problem of knowing whether a peer is alive or dead. This is not an issue specific to ØMQ. TCP has a long timeout (30 minutes or so), that means that it can be impossible to know whether a peer has died, been disconnected, or gone on a weekend to Prague with a case of vodka, a redhead, and a large expense account.</p><p>It's is not easy to get heartbeating right. When writing the Paranoid Pirate examples, it took about five hours to get the heartbeating working properly. The rest of the request-reply chain took perhaps ten minutes. It is especially easy to create "false failures", i.e., when peers decide that they are disconnected because the heartbeats aren't sent properly.</p><p>We'll look at the three main answers people use for heartbeating with ØMQ.</p><div class="sect2" title="Shrugging It Off"><div class="titlepage"><div><div><h3 class="title"><a id="idp19764464"></a>Shrugging It Off</h3></div></div></div><p>The most common approach is to do no heartbeating at all and hope for the best. Many if not most ØMQ applications do this. ØMQ encourages this by hiding peers in many cases. What problems does this approach cause?</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>When we use a ROUTER socket in an application that tracks peers, as peers disconnect and reconnect, the application will leak memory (resources that the application holds for each peer) and get slower and slower.</p></li><li class="listitem"><p>When we use SUB- or DEALER-based data recipients, we can't tell the difference between good silence (there's no data) and bad silence (the other end died). When a recipient knows the other side died, it can for example switch over to a backup route.</p></li><li class="listitem"><p>If we use a TCP connection that stays silent for a long while, it will, in some networks, just die. Sending something (technically, a "keep-alive" more than a heartbeat), will keep the network alive.</p></li></ul></div></div><div class="sect2" title="One-Way Heartbeats"><div class="titlepage"><div><div><h3 class="title"><a id="idp19766952"></a>One-Way Heartbeats</h3></div></div></div><p>A second option is to send a heartbeat message from each node to its peers every second or so. When one node hears nothing from another within some timeout (several seconds, typically), it will treat that peer as dead. Sounds good, right? Sadly, no. This works in some cases but has nasty edge cases in others.</p><p>For pub-sub, this does work, and it's the only model you can use. SUB sockets cannot talk back to PUB sockets, but PUB sockets can happily send "I'm alive" messages to their subscribers.</p><p>As an optimization, you can send heartbeats only when there is no real data to send. Furthermore, you can send heartbeats progressively slower and slower, if network activity is an issue (e.g., on mobile networks where activity drains the battery). As long as the recipient can detect a failure (sharp stop in activity), that's fine.</p><p>Here are the typical problems with this design:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>It can be inaccurate when we send large amounts of data, as heartbeats will be delayed behind that data. If heartbeats are delayed, you can get false timeouts and disconnections due to network congestion. Thus, always treat <span class="emphasis"><em>any</em></span> incoming data as a heartbeat, whether or not the sender optimizes out heartbeats.</p></li><li class="listitem"><p>While the pub-sub pattern will drop messages for disappeared recipients, PUSH and DEALER sockets will queue them. So if you send heartbeats to a dead peer and it comes back, it will get all the heartbeats you sent, which can be thousands. Whoa, whoa!</p></li><li class="listitem"><p>This design assumes that heartbeat timeouts are the same across the whole network. But that won't be accurate. Some peers will want very aggressive heartbeating in order to detect faults rapidly. And some will want very relaxed heartbeating, in order to let sleeping networks lie and save power.</p></li></ul></div></div><div class="sect2" title="Ping-Pong Heartbeats"><div class="titlepage"><div><div><h3 class="title"><a id="idp19770992"></a>Ping-Pong Heartbeats</h3></div></div></div><p>The third option is to use a ping-pong dialog. One peer sends a ping command to the other, which replies with a pong command. Neither command has any payload. Pings and pongs are not correlated. Because the roles of "client" and "server" are arbitrary in some networks, we usually specify that either peer can in fact send a ping and expect a pong in response. However, because the timeouts depend on network topologies known best to dynamic clients, it is usually the client that pings the server.</p><p>This works for all ROUTER-based brokers. The same optimizations we used in the second model make this work even better: treat any incoming data as a pong, and only send a ping when not otherwise sending data.</p></div><div class="sect2" title="Heartbeating for Paranoid Pirate"><div class="titlepage"><div><div><h3 class="title"><a id="idp19772480"></a>Heartbeating for Paranoid Pirate</h3></div></div></div><p>For Paranoid Pirate, we chose the second approach. It might not have been the simplest option: if designing this today, I'd probably try a ping-pong approach instead. However the principles are similar. The heartbeat messages flow asynchronously in both directions, and either peer can decide the other is "dead" and stop talking to it.</p><p>In the worker, this is how we handle heartbeats from the queue:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>We calculate a <span class="emphasis"><em>liveness</em></span>, which is how many heartbeats we can still miss before deciding the queue is dead. It starts at three and we decrement it each time we miss a heartbeat.</p></li><li class="listitem"><p>We wait, in the <code class="literal">zmq_poll</code> loop, for one second each time, which is our heartbeat interval.</p></li><li class="listitem"><p>If there's any message from the queue during that time, we reset our liveness to three.</p></li><li class="listitem"><p>If there's no message during that time, we count down our liveness.</p></li><li class="listitem"><p>If the liveness reaches zero, we consider the queue dead.</p></li><li class="listitem"><p>If the queue is dead, we destroy our socket, create a new one, and reconnect.</p></li><li class="listitem"><p>To avoid opening and closing too many sockets, we wait for a certain interval before reconnecting, and we double the interval each time until it reaches 32 seconds.</p></li></ul></div><p>And this is how we handle heartbeats <span class="emphasis"><em>to</em></span> the queue:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>We calculate when to send the next heartbeat; this is a single variable because we're talking to one peer, the queue.</p></li><li class="listitem"><p>In the <code class="literal">zmq_poll</code> loop, whenever we pass this time, we send a heartbeat to the queue.</p></li></ul></div><p>Here's the essential heartbeating code for the worker:</p><pre class="programlisting">
#define HEARTBEAT_LIVENESS  3       //  3-5 is reasonable
#define HEARTBEAT_INTERVAL  1000    //  msecs
#define INTERVAL_INIT       1000    //  Initial reconnect
#define INTERVAL_MAX       32000    //  After exponential backoff

...
//  If liveness hits zero, queue is considered disconnected
size_t liveness = HEARTBEAT_LIVENESS;
size_t interval = INTERVAL_INIT;

//  Send out heartbeats at regular intervals
uint64_t heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;

while (true) {
    zmq_pollitem_t items [] = { { worker,  0, ZMQ_POLLIN, 0 } };
    int rc = zmq_poll (items, 1, HEARTBEAT_INTERVAL * ZMQ_POLL_MSEC);

    if (items [0].revents &amp; ZMQ_POLLIN) {
        //  Receive any message from queue
        liveness = HEARTBEAT_LIVENESS;
        interval = INTERVAL_INIT;
    }
    else
    if (--liveness == 0) {
        zclock_sleep (interval);
        if (interval &lt; INTERVAL_MAX)
            interval *= 2;
        zsocket_destroy (ctx, worker);
        ...
        liveness = HEARTBEAT_LIVENESS;
    }
    //  Send heartbeat to queue if it's time
    if (zclock_time () &gt; heartbeat_at) {
        heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;
        //  Send heartbeat message to queue
    }
}
</pre><p>The queue does the same, but manages an expiration time for each worker.</p><p>Here are some tips for your own heartbeating implementation:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Use <code class="literal">zmq_poll</code> or a reactor as the core of your application's main task.</p></li><li class="listitem"><p>Start by building the heartbeating between peers, test it by simulating failures, and <span class="emphasis"><em>then</em></span> build the rest of the message flow. Adding heartbeating afterwards is much trickier.</p></li><li class="listitem"><p>Use simple tracing, i.e., print to console, to get this working. To help you trace the flow of messages between peers, use a dump method such as zmsg offers, and number your messages incrementally so you can see if there are gaps.</p></li><li class="listitem"><p>In a real application, heartbeating must be configurable and usually negotiated with the peer. Some peers will want aggressive heartbeating, as low as 10 msecs. Other peers will be far away and want heartbeating as high as 30 seconds.</p></li><li class="listitem"><p>If you have different heartbeat intervals for different peers, your poll timeout should be the lowest (shortest time) of these. Do not use an infinite timeout.</p></li><li class="listitem"><p>Do heartbeating on the same socket you use for messages, so your heartbeats also act as a <span class="emphasis"><em>keep-alive</em></span> to stop the network connection from going stale (some firewalls can be unkind to silent connections).</p></li></ul></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04s05.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch04.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch04s07.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Robust Reliable Queuing (Paranoid Pirate Pattern) </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Contracts and Protocols</td></tr></table></div></body></html>
