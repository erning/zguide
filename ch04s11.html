<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Idempotent Services</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="ch04.html" title="Chapter 4. Reliable Request-Reply Patterns" /><link rel="prev" href="ch04s10.html" title="Service Discovery" /><link rel="next" href="ch04s12.html" title="Disconnected Reliability (Titanic Pattern)" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Idempotent Services</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04s10.html">Prev</a> </td><th width="60%" align="center">Chapter 4. Reliable Request-Reply Patterns</th><td width="20%" align="right"> <a accesskey="n" href="ch04s12.html">Next</a></td></tr></table><hr /></div><div class="sect1" title="Idempotent Services"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp19919664"></a>Idempotent Services</h2></div></div></div><p>Idempotency is not something you take a pill for. What it means is that it's safe to repeat an operation. Checking the clock is idempotent. Lending ones credit card to ones children is not. While many client-to-server use cases are idempotent, some are not. Examples of idempotent use cases include:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Stateless task distribution, i.e., a pipeline where the servers are stateless workers that compute a reply based purely on the state provided by a request. In such a case, it's safe (though inefficient) to execute the same request many times.</p></li><li class="listitem"><p>A name service that translates logical addresses into endpoints to bind or connect to. In such a case, it's safe to make the same lookup request many times.</p></li></ul></div><p>And here are examples of a non-idempotent use cases:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>A logging service. One does not want the same log information recorded more than once.</p></li><li class="listitem"><p>Any service that has impact on downstream nodes, e.g., sends on information to other nodes. If that service gets the same request more than once, downstream nodes will get duplicate information.</p></li><li class="listitem"><p>Any service that modifies shared data in some non-idempotent way; e.g., a service that debits a bank account is not idempotent without extra work.</p></li></ul></div><p>When our server applications are not idempotent, we have to think more carefully about when exactly they might crash. If an application dies when it's idle, or while it's processing a request, that's usually fine. We can use database transactions to make sure a debit and a credit are always done together, if at all. If the server dies while sending its reply, that's a problem, because as far as it's concerned, it has done its work.</p><p>If the network dies just as the reply is making its way back to the client, the same problem arises. The client will think the server died and will resend the request, and the server will do the same work twice, which is not what we want.</p><p>To handle non-idempotent operations, use the fairly standard solution of detecting and rejecting duplicate requests. This means:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The client must stamp every request with a unique client identifier and a unique message number.</p></li><li class="listitem"><p>The server, before sending back a reply, stores it using the combination of client ID and message number as a key.</p></li><li class="listitem"><p>The server, when getting a request from a given client, first checks whether it has a reply for that client ID and message number. If so, it does not process the request, but just resends the reply.</p></li></ul></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04s10.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch04.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch04s12.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Service Discovery </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Disconnected Reliability (Titanic Pattern)</td></tr></table></div></body></html>
