<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Distributed Logging and Monitoring</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="ch08.html" title="Chapter 8. A Framework for Distributed Computing" /><link rel="prev" href="ch08s07.html" title="Testing and Simulation" /><link rel="next" href="ch08s09.html" title="Content Distribution" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Distributed Logging and Monitoring</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch08s07.html">Prev</a> </td><th width="60%" align="center">Chapter 8. A Framework for Distributed Computing</th><td width="20%" align="right"> <a accesskey="n" href="ch08s09.html">Next</a></td></tr></table><hr /></div><div class="sect1" title="Distributed Logging and Monitoring"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp21430976"></a>Distributed Logging and Monitoring</h2></div></div></div><p>Let's look at logging and monitoring. If you've ever managed a real server (like a web server), you know how vital it is to have a capture of what is going on. There are a long list of reasons, not least:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>To measure the performance of the system over time.</p></li><li class="listitem"><p>To see what kinds of work are done the most, to optimize performance.</p></li><li class="listitem"><p>To track errors and how often they occur.</p></li><li class="listitem"><p>To do postmortems of failures.</p></li><li class="listitem"><p>To provide an audit trail in case of dispute.</p></li></ul></div><p>Let's scope this in terms of the problems we think we'll have to solve:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>We want to track key events (such as nodes leaving and rejoining the network).</p></li><li class="listitem"><p>For each event, we want to track a consistent set of data: the date/time, node that observed the event, peer that created the event, type of event itself, and other event data.</p></li><li class="listitem"><p>We want to be able to switch logging on and off at any time.</p></li><li class="listitem"><p>We want to be able to process log data mechanically because it will be sizable.</p></li><li class="listitem"><p>We want to be able to monitor a running system; that is, collect logs and analyze in real time.</p></li><li class="listitem"><p>We want log traffic to have minimal effect on the network.</p></li><li class="listitem"><p>We want to be able to collect log data at a single point on the network.</p></li></ul></div><p>As in any design, some of these requirements are hostile to each other. For example, collecting log data in real time means sending it over the network, which will affect network traffic to some extent. However, as in any design, these requirements are also hypothetical until we have running code so we can't take them too seriously. We'll aim for <span class="emphasis"><em>plausibly good enough</em></span> and improve over time.</p><div class="sect2" title="A Plausible Minimal Implementation"><div class="titlepage"><div><div><h3 class="title"><a id="idp21437200"></a>A Plausible Minimal Implementation</h3></div></div></div><p>Arguably, just dumping log data to disk is one solution, and it's what most mobile applications do (using "debug logs"). But most failures require correlation of events from two nodes. This means searching lots of debug logs by hand to find the ones that matter. It's not a very clever approach.</p><p>We want to send log data somewhere central, either immediately, or opportunistically (i.e., store and forward). For now, let's focus on immediate logging. My first idea when it comes to sending data is to use Zyre for this. Just send log data to a group called "LOG", and hope someone collects it.</p><p>But using Zyre to log Zyre itself is a Catch-22. Who logs the logger? What if we want a verbose log of every message sent? Do we include logging messages in that or not? It quickly gets messy. We want a logging protocol that's independent of Zyre's main ZRE protocol. The simplest approach is a pub-sub protocol, where all nodes publish log data on a PUB socket and a collector picks that up via a SUB socket<a class="xref" href="ch08s08.html#figure-69" title="Figure 8.3. Distributed Log Collection">Figure 8.3, “Distributed Log Collection”</a>.</p><div class="figure"><a id="figure-69"></a><p class="title"><strong>Figure 8.3. Distributed Log Collection</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/fig69.png" alt="Distributed Log Collection" /></div></div></div><br class="figure-break" /><p>The collector can, of course, run on any node. This gives us a nice range of use cases:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>A passive log collector that stores log data on disk for eventual statistical analysis; this would be a PC with sufficient hard disk space for weeks or months of log data.</p></li><li class="listitem"><p>A collector that stores log data into a database where it can be used in real time by other applications. This might be overkill for a small workgroup, but would be snazzy for tracking the performance of larger groups. The collector could collect log data over WiFi and then forward it over Ethernet to a database somewhere.</p></li><li class="listitem"><p>A live meter application that joined the Zyre network and then collected log data from nodes, showing events and statistics in real time.</p></li></ul></div><p>The next question is how to interconnect the nodes and collector. Which side binds, and which connects? Both ways will work here, but it's marginally better if the PUB sockets connect to the SUB socket. If you recall, ØMQ's internal buffers only pop into existence when there are connections. It means as soon as a node connects to the collector, it can start sending log data without loss.</p><p>How do we tell nodes what endpoint to connect to? We may have any number of collectors on the network, and they'll be using arbitrary network addresses and ports. We need some kind of service announcement mechanism, and here we can use Zyre to do the work for us. We could use group messaging, but it seems neater to build service discovery into the ZRE protocol itself. It's nothing complex: if a node provides a service X, it can tell other nodes about that when it sends them a <code class="literal">HELLO</code> command.</p><p>We'll extend the <code class="literal">HELLO</code> command with a <span class="emphasis"><em>headers</em></span> field that holds a set of name=value pairs. Let's define that the header <code class="literal">X-ZRELOG</code> specifies the collector endpoint (the SUB socket). A node that acts as a collector can add a header like this (for example):</p><pre class="screen">X-ZRELOG=tcp://192.168.1.122:9992
</pre><p>When another node sees this header, it simply connects its PUB socket to that endpoint. Log data now gets distributed to all collectors (zero or more) on the network.</p><p>Making this first version was fairly simple and took half a day. Here are the pieces we had to make or change:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>We made a new class <code class="literal">zre_log</code> that accepts log data and manages the connection to the collector, if any.</p></li><li class="listitem"><p>We added some basic management for peer headers, taken from the <code class="literal">HELLO</code> command.</p></li><li class="listitem"><p>When a peer has the <code class="literal">X-ZRELOG</code> header, we connect to the endpoint it specifies.</p></li><li class="listitem"><p>Where we were logging to stdout, we switched to logging via the <code class="literal">zre_log</code> class.</p></li><li class="listitem"><p>We extended the interface API with a method that lets the application set headers.</p></li><li class="listitem"><p>We wrote a simple logger application that manages the SUB socket and sets the <code class="literal">X-ZRELOG</code> header.</p></li><li class="listitem"><p>We send our own headers when we send a <code class="literal">HELLO</code> command.</p></li></ul></div><p>This version is tagged in the Zyre repository as v0.4.0 and you can <a class="ulink" href="https://github.com/zeromq/zyre/tags" target="_top">download the tarball</a> if you want to see what the code looked like at this stage.</p><p>At this stage, the log message is just a string. We'll make more professionally structured log data in a little while.</p><p>First, a note on dynamic ports. In the <code class="literal">zre_tester</code> app that we use for testing, we create and destroy interfaces aggressively. One consequence is that a new interface can easily reuse a port that was just freed by another application. If there's a ØMQ socket somewhere trying to connect this port, the results can be hilarious.</p><p>Here's the scenario I had, which caused a few minutes' confusion. The logger was running on a dynamic port:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Start logger application</p></li><li class="listitem"><p>Start tester application</p></li><li class="listitem"><p>Stop logger</p></li><li class="listitem"><p>Tester receives invalid message (and asserts as designed)</p></li></ul></div><p>As the tester created a new interface, that reused the dynamic port freed by the (just stopped) logger, and suddenly the interface began to receive log data from nodes on its mailbox. We saw a similar situation before, where a new interface could reuse the port freed by an old interface and start getting old data.</p><p>The lesson is, if you use dynamic ports, be prepared to receive random data from ill-informed applications that are reconnecting to you. Switching to a static port stopped the misbehaving connection. That's not a full solution though. There are two more weaknesses:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>As I write this, <code class="literal">libzmq</code> doesn't check socket types when connecting. The <a class="ulink" href="http://rfc.zeromq.org/spec:15" target="_top">ZMTP/2.0 protocol</a> does announce each peer's socket type, so this check is doable.</p></li><li class="listitem"><p>The ZRE protocol has no fail-fast (assertion) mechanism; we need to read and parse a whole message before realizing that it's invalid.</p></li></ul></div><p>Let's address the second one. Socket pair validation wouldn't solve this fully anyway.</p></div><div class="sect2" title="Protocol Assertions"><div class="titlepage"><div><div><h3 class="title"><a id="idp21458192"></a>Protocol Assertions</h3></div></div></div><p>As Wikipedia puts it, "Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly flawed process." A protocol like HTTP has a fail-fast mechanism in that the first four bytes that a client sends to an HTTP server must be "HTTP". If they're not, the server can close the connection without reading anything more.</p><p>Our ROUTER socket is not connection-oriented so there's no way to "close the connection" when we get bad incoming messages. However, we can throw out the entire message if it's not valid. The problem is going to be worse when we use ephemeral ports, but it applies broadly to all protocols.</p><p>So let's define a <span class="emphasis"><em>protocol assertion</em></span> as being a unique signature that we place at the start of each message and which identities the intended protocol. When we read a message, we check the signature and if it's not what we expect, we discard the message silently. A good signature should be hard to confuse with regular data and give us enough space for a number of protocols.</p><p>I'm going to use a 16-bit signature consisting of a 12-bit pattern and a 4-bit protocol ID<a class="xref" href="ch08s08.html#figure-70" title="Figure 8.4. Protocol Signature">Figure 8.4, “Protocol Signature”</a>. The pattern %xAAA is meant to stay away from values we might otherwise expect to see at the start of a message: %x00, %xFF, and printable characters.</p><div class="figure"><a id="figure-70"></a><p class="title"><strong>Figure 8.4. Protocol Signature</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/fig70.png" alt="Protocol Signature" /></div></div></div><br class="figure-break" /><p>As our protocol codec is generated, it's relatively easy to add this assertion. The logic is:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Get first frame of message.</p></li><li class="listitem"><p>Check if first two bytes are %xAAA with expected 4-bit signature.</p></li><li class="listitem"><p>If so, continue to parse rest of message.</p></li><li class="listitem"><p>If not, skip all "more" frames, get first frame, and repeat.</p></li></ul></div><p>To test this, I switched the logger back to using an ephemeral port. The interface now properly detects and discards any messages that don't have a valid signature. If the message has a valid signature and is <span class="emphasis"><em>still</em></span> wrong, that's a proper bug.</p></div><div class="sect2" title="Binary Logging Protocol"><div class="titlepage"><div><div><h3 class="title"><a id="idp21465368"></a>Binary Logging Protocol</h3></div></div></div><p>Now that we have the logging framework working properly, let's look at the protocol itself. Sending strings around the network is simple, but when it comes to WiFi we really cannot afford to waste bandwidth. We have the tools to work with efficient binary protocols, so let's design one for logging.</p><p>This is going to be a pub-sub protocol and in ØMQ v3.x we do publisher-side filtering. This means we can do multi-level logging (errors, warnings, information) if we put the logging level at the start of the message. So our message starts with a protocol signature (two bytes), a logging level (one byte), and an event type (one byte).</p><p>In the first version, we send UUID strings to identify each node. As text, these are 32 characters each. We can send binary UUIDs, but it's still verbose and wasteful. We don't care about the node identifiers in the log files. All we need is some way to correlate events. So what's the shortest identifier we can use that's going to be unique enough for logging? I say "unique enough" because while we really want zero chance of duplicate UUIDs in the live code, log files are not so critical.</p><p>The simplest plausible answer is to hash the IP address and port into a 2-byte value. We'll get some collisions, but they'll be rare. How rare? As a quick sanity check, I write a small program that generates a bunch of addresses and hashes them into 16-bit values, looking for collisions. To be sure, I generate 10,000 addresses across a small number of IP addresses (matching a simulation setup), and then across a large number of addresses (matching a real-life setup). The hashing algorithm is a <span class="emphasis"><em>modified Bernstein</em></span>:</p><pre class="programlisting">
uint16_t hash = 0;
while (*endpoint)
    hash = 33 * hash ^ *endpoint++;
</pre><p>I don't get any collisions over several runs, so this will work as identifier for the log data. This adds four bytes (two for the node recording the event, and two for its peer in events that come from a peer).</p><p>Next, we want to store the date and time of the event. The POSIX <code class="literal">time_t</code> type was previously 32 bits, but because this overflows in 2038, it's a 64-bit value. We'll use this; there's no need for millisecond resolution in a log file: events are sequential, clocks are unlikely to be that tightly synchronized, and network latencies mean that precise times aren't that meaningful.</p><p>We're up to 16 bytes, which is decent. Finally, we want to allow some additional data, formatted as text and depending on the type of event. Putting this all together gives the following message specification:</p><pre class="screen">&lt;class
    name = "zre_log_msg"
    script = "codec_c.gsl"
    signature = "2"
&gt;
This is the ZRE logging protocol - raw version.
&lt;include filename = "license.xml" /&gt;

&lt;!-- Protocol constants --&gt;
&lt;define name = "VERSION" value = "1" /&gt;

&lt;define name = "LEVEL_ERROR" value = "1" /&gt;
&lt;define name = "LEVEL_WARNING" value = "2" /&gt;
&lt;define name = "LEVEL_INFO" value = "3" /&gt;

&lt;define name = "EVENT_JOIN" value = "1" /&gt;
&lt;define name = "EVENT_LEAVE" value = "2" /&gt;
&lt;define name = "EVENT_ENTER" value = "3" /&gt;
&lt;define name = "EVENT_EXIT" value = "4" /&gt;

&lt;message name = "LOG" id = "1"&gt;
    &lt;field name = "level" type = "number" size = "1" /&gt;
    &lt;field name = "event" type = "number" size = "1" /&gt;
    &lt;field name = "node" type = "number" size = "2" /&gt;
    &lt;field name = "peer" type = "number" size = "2" /&gt;
    &lt;field name = "time" type = "number" size = "8" /&gt;
    &lt;field name = "data" type = "string" /&gt;
Log an event
&lt;/message&gt;

&lt;/class&gt;
</pre><p>This generates 800 lines of perfect binary codec (the <code class="literal">zre_log_msg</code> class). The codec does protocol assertions just like the main ZRE protocol does. Code generation has a fairly steep starting curve, but it makes it so much easier to push your designs past "amateur" into "professional".</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch08s07.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch08.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch08s09.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Testing and Simulation </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Content Distribution</td></tr></table></div></body></html>
