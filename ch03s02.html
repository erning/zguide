<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Request-Reply Combinations</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The ZeroMQ Guide - for C Developers" /><link rel="up" href="ch03.html" title="Chapter 3. Advanced Request-Reply Patterns" /><link rel="prev" href="ch03.html" title="Chapter 3. Advanced Request-Reply Patterns" /><link rel="next" href="ch03s03.html" title="Exploring ROUTER Sockets" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Request-Reply Combinations</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03.html">Prev</a> </td><th width="60%" align="center">Chapter 3. Advanced Request-Reply Patterns</th><td width="20%" align="right"> <a accesskey="n" href="ch03s03.html">Next</a></td></tr></table><hr /></div><div class="sect1" title="Request-Reply Combinations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp19394448"></a>Request-Reply Combinations</h2></div></div></div><p>We have four request-reply sockets, each with a certain behavior. We've seen how they connect in simple and extended request-reply patterns. But these sockets are building blocks that you can use to solve many problems.</p><p>These are the legal combinations:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>REQ to REP</p></li><li class="listitem"><p>DEALER to REP</p></li><li class="listitem"><p>REQ to ROUTER</p></li><li class="listitem"><p>DEALER to ROUTER</p></li><li class="listitem"><p>DEALER to DEALER</p></li><li class="listitem"><p>ROUTER to ROUTER</p></li></ul></div><p>And these combinations are invalid (and I'll explain why):</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>REQ to REQ</p></li><li class="listitem"><p>REQ to DEALER</p></li><li class="listitem"><p>REP to REP</p></li><li class="listitem"><p>REP to ROUTER</p></li></ul></div><p>Here are some tips for remembering the semantics. DEALER is like an asynchronous REQ socket, and ROUTER is like an asynchronous REP socket. Where we use a REQ socket, we can use a DEALER; we just have to read and write the envelope ourselves. Where we use a REP socket, we can stick a ROUTER; we just need to manage the identities ourselves.</p><p>Think of REQ and DEALER sockets as "clients" and REP and ROUTER sockets as "servers". Mostly, you'll want to bind REP and ROUTER sockets, and connect REQ and DEALER sockets to them. It's not always going to be this simple, but it is a clean and memorable place to start.</p><div class="sect2" title="The REQ to REP Combination"><div class="titlepage"><div><div><h3 class="title"><a id="idp19399632"></a>The REQ to REP Combination</h3></div></div></div><p>We've already covered a REQ client talking to a REP server but let's take one aspect: the REQ client <span class="emphasis"><em>must</em></span> initiate the message flow. A REP server cannot talk to a REQ client that hasn't first sent it a request. Technically, it's not even possible, and the API also returns an <code class="literal">EFSM</code> error if you try it.</p></div><div class="sect2" title="The DEALER to REP Combination"><div class="titlepage"><div><div><h3 class="title"><a id="idp19401000"></a>The DEALER to REP Combination</h3></div></div></div><p>Now, let's replace the REQ client with a DEALER. This gives us an asynchronous client that can talk to multiple REP servers. If we rewrote the "Hello World" client using DEALER, we'd be able to send off any number of "Hello" requests without waiting for replies.</p><p>When we use a DEALER to talk to a REP socket, we <span class="emphasis"><em>must</em></span> accurately emulate the envelope that the REQ socket would have sent, or the REP socket will discard the message as invalid. So, to send a message, we:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Send an empty message frame with the MORE flag set; then</p></li><li class="listitem"><p>Send the message body.</p></li></ul></div><p>And when we receive a message, we:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Receive the first frame and if it's not empty, discard the whole message;</p></li><li class="listitem"><p>Receive the next frame and pass that to the application.</p></li></ul></div></div><div class="sect2" title="The REQ to ROUTER Combination"><div class="titlepage"><div><div><h3 class="title"><a id="idp19404336"></a>The REQ to ROUTER Combination</h3></div></div></div><p>In the same way that we can replace REQ with DEALER, we can replace REP with ROUTER. This gives us an asynchronous server that can talk to multiple REQ clients at the same time. If we rewrote the "Hello World" server using ROUTER, we'd be able to process any number of "Hello" requests in parallel. We saw this in the Sockets and Patterns<a class="xref" href="ch02.html" title="Chapter 2. Sockets and Patterns">Chapter 2, <em>Sockets and Patterns</em></a> <code class="literal">mtserver</code> example.</p><p>We can use ROUTER in two distinct ways:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>As a proxy that switches messages between frontend and backend sockets.</p></li><li class="listitem"><p>As an application that reads the message and acts on it.</p></li></ul></div><p>In the first case, the ROUTER simply reads all frames, including the artificial identity frame, and passes them on blindly. In the second case the ROUTER <span class="emphasis"><em>must</em></span> know the format of the reply envelope it's being sent. As the other peer is a REQ socket, the ROUTER gets the identity frame, an empty frame, and then the data frame.</p></div><div class="sect2" title="The DEALER to ROUTER Combination"><div class="titlepage"><div><div><h3 class="title"><a id="idp19407664"></a>The DEALER to ROUTER Combination</h3></div></div></div><p>Now we can switch out both REQ and REP with DEALER and ROUTER to get the most powerful socket combination, which is DEALER talking to ROUTER. It gives us asynchronous clients talking to asynchronous servers, where both sides have full control over the message formats.</p><p>Because both DEALER and ROUTER can work with arbitrary message formats, if you hope to use these safely, you have to become a little bit of a protocol designer. At the very least you must decide whether you wish to emulate the REQ/REP reply envelope. It depends on whether you actually need to send replies or not.</p></div><div class="sect2" title="The DEALER to DEALER Combination"><div class="titlepage"><div><div><h3 class="title"><a id="idp19409072"></a>The DEALER to DEALER Combination</h3></div></div></div><p>You can swap a REP with a ROUTER, but you can also swap a REP with a DEALER, if the DEALER is talking to one and only one peer.</p><p>When you replace a REP with a DEALER, your worker can suddenly go full asynchronous, sending any number of replies back. The cost is that you have to manage the reply envelopes yourself, and get them right, or nothing at all will work. We'll see a worked example later. Let's just say for now that DEALER to DEALER is one of the trickier patterns to get right, and happily it's rare that we need it.</p></div><div class="sect2" title="The ROUTER to ROUTER Combination"><div class="titlepage"><div><div><h3 class="title"><a id="idp19410424"></a>The ROUTER to ROUTER Combination</h3></div></div></div><p>This sounds perfect for N-to-N connections, but it's the most difficult combination to use. You should avoid it until you are well advanced with ØMQ. We'll see one example it in the Freelance pattern in Reliable Request-Reply Patterns<a class="xref" href="ch04.html" title="Chapter 4. Reliable Request-Reply Patterns">Chapter 4, <em>Reliable Request-Reply Patterns</em></a>, and an alternative DEALER to ROUTER design for peer-to-peer work in A Framework for Distributed Computing<a class="xref" href="ch08.html" title="Chapter 8. A Framework for Distributed Computing">Chapter 8, <em>A Framework for Distributed Computing</em></a>.</p></div><div class="sect2" title="Invalid Combinations"><div class="titlepage"><div><div><h3 class="title"><a id="idp19411920"></a>Invalid Combinations</h3></div></div></div><p>Mostly, trying to connect clients to clients, or servers to servers is a bad idea and won't work. However, rather than give general vague warnings, I'll explain in detail:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>REQ to REQ: both sides want to start by sending messages to each other, and this could only work if you timed things so that both peers exchanged messages at the same time. It hurts my brain to even think about it.</p></li><li class="listitem"><p>REQ to DEALER: you could in theory do this, but it would break if you added a second REQ because DEALER has no way of sending a reply to the original peer. Thus the REQ socket would get confused, and/or return messages meant for another client.</p></li><li class="listitem"><p>REP to REP: both sides would wait for the other to send the first message.</p></li><li class="listitem"><p>REP to ROUTER: the ROUTER socket can in theory initiate the dialog and send a properly-formatted request, if it knows the REP socket has connected <span class="emphasis"><em>and</em></span> it knows the identity of that connection. It's messy and adds nothing over DEALER to ROUTER.</p></li></ul></div><p>The common thread in this valid versus invalid breakdown is that a ØMQ socket connection is always biased towards one peer that binds to an endpoint, and another that connects to that. Further, that which side binds and which side connects is not arbitrary, but follows natural patterns. The side which we expect to "be there" binds: it'll be a server, a broker, a publisher, a collector. The side that "comes and goes" connects: it'll be clients and workers. Remembering this will help you design better ØMQ architectures.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch03.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch03s03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 3. Advanced Request-Reply Patterns </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Exploring ROUTER Sockets</td></tr></table></div></body></html>
